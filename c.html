
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>auth: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/cmd/auth/main.go (0.0%)</option>
				
				<option value="file1">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/cmd/main.go (0.0%)</option>
				
				<option value="file2">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/cmd/order/main.go (0.0%)</option>
				
				<option value="file3">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/config/config.go (0.0%)</option>
				
				<option value="file4">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/config/configRouting/configMiddleware.go (0.0%)</option>
				
				<option value="file5">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/config/configRouting/configRouting.go (0.0%)</option>
				
				<option value="file6">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/config/configRouting/corsConf.go (0.0%)</option>
				
				<option value="file7">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/config/configRouting/csrfConf.go (0.0%)</option>
				
				<option value="file8">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/docs/docs.go (100.0%)</option>
				
				<option value="file9">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/address/delivery/http/handler.go (100.0%)</option>
				
				<option value="file10">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/address/mock/AddressRepository.go (65.0%)</option>
				
				<option value="file11">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/address/mock/SuggestUseCase.go (100.0%)</option>
				
				<option value="file12">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/address/repository/repository.go (94.7%)</option>
				
				<option value="file13">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/address/usecase/usecase.go (76.2%)</option>
				
				<option value="file14">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/comments/delivery/http/handler.go (0.0%)</option>
				
				<option value="file15">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/comments/repository/repository.go (0.0%)</option>
				
				<option value="file16">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/comments/usecase/usecase.go (0.0%)</option>
				
				<option value="file17">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/delivery/http/httpErrDescr/httpErrDescr.go (100.0%)</option>
				
				<option value="file18">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/delivery/http/middleware/accessLogMiddleware.go (36.4%)</option>
				
				<option value="file19">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/delivery/http/middleware/authMiddleware.go (0.0%)</option>
				
				<option value="file20">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/delivery/http/middleware/csrfMiddleware.go (0.0%)</option>
				
				<option value="file21">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/delivery/http/middleware/errorHandler.go (0.0%)</option>
				
				<option value="file22">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/delivery/http/middleware/middleware.go (0.0%)</option>
				
				<option value="file23">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/delivery/http/middleware/panicMiddleware.go (0.0%)</option>
				
				<option value="file24">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/delivery/http/middleware/requestIdMiddleware.go (30.0%)</option>
				
				<option value="file25">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/dishes/delivery/http/handler.go (88.0%)</option>
				
				<option value="file26">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/dishes/mock/repository.go (66.7%)</option>
				
				<option value="file27">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/dishes/mock/usecase.go (75.0%)</option>
				
				<option value="file28">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/dishes/repository/repository.go (93.8%)</option>
				
				<option value="file29">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/dishes/usecase/usecase.go (81.8%)</option>
				
				<option value="file30">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/metrics/hendler.go (0.0%)</option>
				
				<option value="file31">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/metrics/metricsMiddlewere.go (0.0%)</option>
				
				<option value="file32">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/order/delivery/http/handler.go (0.0%)</option>
				
				<option value="file33">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/order/usecase/usecase.go (0.0%)</option>
				
				<option value="file34">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/restaurants/delivery/http/handler.go (87.3%)</option>
				
				<option value="file35">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/restaurants/mock/usecase.go (100.0%)</option>
				
				<option value="file36">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/restaurants/repository/repository.go (0.0%)</option>
				
				<option value="file37">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/restaurants/usecase/usecase.go (0.0%)</option>
				
				<option value="file38">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/authManager/authManager.go (0.0%)</option>
				
				<option value="file39">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/authManager/jwtManager/jwtManager.go (0.0%)</option>
				
				<option value="file40">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/cacher/cacher.go (0.0%)</option>
				
				<option value="file41">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/cacher/memcacher/memcacher.go (0.0%)</option>
				
				<option value="file42">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/logger/logger.go (33.3%)</option>
				
				<option value="file43">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/logger/mock/logger.go (0.0%)</option>
				
				<option value="file44">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/logger/zaplogger/zapLogger.go (0.0%)</option>
				
				<option value="file45">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/notification/flashcall/flashcall.go (0.0%)</option>
				
				<option value="file46">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/postgresqlx/postgres.go (0.0%)</option>
				
				<option value="file47">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/servErrors/servErrors.go (77.8%)</option>
				
				<option value="file48">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/staticManager/localStaticManager/localStaticmanager.go (23.1%)</option>
				
				<option value="file49">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/validator/validator.go (29.4%)</option>
				
				<option value="file50">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/user/delivery/http/handler.go (0.0%)</option>
				
				<option value="file51">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/user/repository/repository.go (0.0%)</option>
				
				<option value="file52">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/user/usecase/usecase.go (0.0%)</option>
				
				<option value="file53">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/auth/delivery/grpc/handler.go (0.0%)</option>
				
				<option value="file54">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/auth/repository/repository.go (0.0%)</option>
				
				<option value="file55">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/auth/usecase/usecase.go (0.0%)</option>
				
				<option value="file56">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/order/delivery/grpc/handler.go (0.0%)</option>
				
				<option value="file57">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/order/repository/repository.go (0.0%)</option>
				
				<option value="file58">github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/order/usecase/usecase.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "flag"
        "log"
        "net"

        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/postgresqlx"
        "github.com/pkg/errors"
        "google.golang.org/grpc"

        conf "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/config"

        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/cacher/memcacher"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/notification/flashcall"
        authHandler "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/auth/delivery/grpc"
        authRepo "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/auth/repository"
        authUcase "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/auth/usecase"

        authProto "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/auth/proto"
)

func main() <span class="cov0" title="0">{
        configPath := flag.String("config", "../../config/auth.toml", "path to config file")
        flag.Parse()

        config := conf.NewAuthMicroserviceConfig()
        err := conf.ReadConfigFile(*configPath, config)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(errors.Wrap(err, "error reading config"))
        }</span>

        <span class="cov0" title="0">pgxManager, err := postgresqlx.NewPostgresqlX(&amp;config.DatabaseConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(errors.Wrap(err, "error creating postgres agent"))
        }</span>
        <span class="cov0" title="0">defer pgxManager.Close()

        // jwtManager := jwt.NewJwtManager(config.AuthentificatorConfig)

        // if jwtManager == nil {
        //         log.Fatal(errors.Wrap(err, "error creating jwt-manager object"))
        // }

        memcacher, err := memcacher.NewMemcacher(&amp;config.CacherConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(errors.Wrap(err, "error creating memcacher"))
        }</span>

        <span class="cov0" title="0">flashcaller := flashcall.NewFlashcaller(&amp;config.NotificatorConfig)

        authRepo := authRepo.NewAuthRepo(pgxManager)

        authUcase := authUcase.NewAuthUcase(flashcaller, memcacher, authRepo)

        authHandler := authHandler.NewAuthHandler(authUcase)

        lis, err := net.Listen("tcp", config.AuthServConfig.BindAddr)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln("cant listen port", err)
        }</span>

        <span class="cov0" title="0">server := grpc.NewServer()

        authProto.RegisterAuthServiceServer(server, authHandler)

        server.Serve(lis)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "flag"
        "log"
        "net/http"
        "time"

        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/metrics"

        "github.com/labstack/echo/v4"
        "github.com/pkg/errors"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"

        conf "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/config"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/config/configRouting"

        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/delivery/http/middleware"
        jwt "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/authManager/jwtManager"

        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/cacher/memcacher"
        servLog "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/logger"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/logger/zaplogger"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/notification/flashcall"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/postgresqlx"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/staticManager/localStaticManager"

        authProto "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/auth/proto"
        orderProto "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/order/proto"

        suggsHandler "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/address/delivery/http"
        suggsRepo "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/address/repository"
        suggsUcase "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/address/usecase"
        commentHandler "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/comments/delivery/http"
        commentRepo "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/comments/repository"
        commentUcase "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/comments/usecase"
        dishesHandler "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/dishes/delivery/http"
        dishesRepo "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/dishes/repository"
        dishesUcase "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/dishes/usecase"
        orderHandler "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/order/delivery/http"
        orderUcase "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/order/usecase"
        restaurantsHandler "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/restaurants/delivery/http"
        restaurantsRepo "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/restaurants/repository"
        restaurantsUcase "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/restaurants/usecase"
        userHandler "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/user/delivery/http"
        userRepo "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/user/repository"
        userUcase "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/user/usecase"
)

// @title           Swagger Example API
// @version         1.0
// @description     This is a sample server celler server.
// @termsOfService  http://swagger.io/terms/

// @contact.name   API Support
// @contact.url    http://www.swagger.io/support
// @contact.email  support@swagger.io

// @license.name  Apache 2.0
// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html

// @host      localhost:8080
// @BasePath  /api/v1

func main() <span class="cov0" title="0">{
        configPath := flag.String("config", "../config/serv.toml", "path to config file")
        flag.Parse()

        config := conf.NewConfig()
        err := conf.ReadConfigFile(*configPath, config)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(errors.Wrap(err, "error reading config"))
        }</span>

        <span class="cov0" title="0">pgxManager, err := postgresqlx.NewPostgresqlX(&amp;config.DatabaseConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(errors.Wrap(err, "error creating postgres agent"))
        }</span>
        <span class="cov0" title="0">defer pgxManager.Close()

        logger, err := zaplogger.NewZapLogger(&amp;config.LoggerConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(errors.Wrap(err, "error creating logger object"))
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                err := logger.Sync()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal("Error occurred in logger sync")
                }</span>
        }()

        <span class="cov0" title="0">servLogger := servLog.NewServLogger(logger)

        jwtManager := jwt.NewJwtManager(config.AuthentificatorConfig)

        if jwtManager == nil </span><span class="cov0" title="0">{
                log.Fatal(errors.Wrap(err, "error creating jwt-manager object"))
        }</span>

        <span class="cov0" title="0">memcacher, err := memcacher.NewMemcacher(&amp;config.CacherConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(errors.Wrap(err, "error creating memcacher"))
        }</span>

        <span class="cov0" title="0">flashcaller := flashcall.NewFlashcaller(&amp;config.NotificatorConfig)

        staticManager := localStaticManager.NewLocalFileManager(config.ServConfig.StaticUrl, config.ServConfig.StaticPath)

        authGrpcConn, err := grpc.Dial(
                config.AuthMicroserverAddr,
                // grpc.WithInsecure(),
                grpc.WithTransportCredentials(insecure.NewCredentials()),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(errors.Wrap(err, "error connecting to grpc-auth-microserver"))
        }</span>
        <span class="cov0" title="0">defer authGrpcConn.Close()

        authorizerCli := authProto.NewAuthServiceClient(authGrpcConn)

        orderGrpcConn, err := grpc.Dial(
                config.OrderMicroserverAddr,
                grpc.WithTransportCredentials(insecure.NewCredentials()),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(errors.Wrap(err, "error connecting to grpc-auth-microserver"))
        }</span>
        <span class="cov0" title="0">defer authGrpcConn.Close()

        orderCli := orderProto.NewOrderServiceClient(orderGrpcConn)

        userRepo := userRepo.NewUserRepo(pgxManager)
        suggsRepo := suggsRepo.NewAddrRepo(pgxManager)

        userUcase := userUcase.NewUcase(flashcaller, memcacher, userRepo, staticManager, authorizerCli)
        suggsUcase := suggsUcase.NewAddrUcase(suggsRepo)
        orderUcase := orderUcase.NewUcase(orderCli)

        userHandler := userHandler.NewUserHandler(userUcase, jwtManager, staticManager)
        suggsHandler := suggsHandler.NewSuggsHandler(suggsUcase)
        orderHandler := orderHandler.NewOrderHandler(orderUcase, staticManager)

        restaurantsRepo := restaurantsRepo.NewRestaurantsRepo(pgxManager)
        restaurantsUcase := restaurantsUcase.NewRestaurantsUcase(restaurantsRepo)
        restaurantsHandler := restaurantsHandler.NewRestaurantsHandler(restaurantsUcase, staticManager)

        dishesRepo := dishesRepo.NewDishesRepo(pgxManager)
        dishesUcase := dishesUcase.NewDishesUcase(dishesRepo)
        dishesHandler := dishesHandler.NewDishesHandler(dishesUcase, staticManager)

        commentsRepo := commentRepo.NewCommentsRepo(pgxManager)
        commentsUcase := commentUcase.NewCommentsUcase(commentsRepo)
        commentsHandler := commentHandler.NewCommentsHandler(commentsUcase)

        router := echo.New()

        m, err := metrics.CreateNewMetric("main")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">router.Use(m.CollectMetrics)

        serverRouting := configRouting.ServerHandlers{
                UserHandler:        userHandler,
                RestaurantsHandler: restaurantsHandler,
                SuggsHandler:       suggsHandler,
                OrderHandler:       orderHandler,
                DishesHandler:      dishesHandler,
                CommentsHandler:    commentsHandler,
        }

        serverRouting.ConfigureRouting(router)

        comonMwChain := middleware.NewCommonMiddlewareChain(servLogger, jwtManager)
        configRouting.ConfigureCommonMiddleware(router, &amp;comonMwChain, &amp;config.CorsConfig, &amp;config.CsrfConfig)

        httpServ := http.Server{
                Addr:         config.ServConfig.BindAddr,
                ReadTimeout:  time.Duration(config.ServConfig.ReadTimeout) * time.Second,
                WriteTimeout: time.Duration(config.ServConfig.WriteTimeout) * time.Second,
                Handler:      router,
        }

        if err := router.StartServer(&amp;httpServ); err != http.ErrServerClosed </span><span class="cov0" title="0">{
                // if err := httpServ.ListenAndServeTLS("../localhost.crt", "../localhost.key"); err != http.ErrServerClosed {
                // if err := router.StartAutoTLS(":8080"); err != http.ErrServerClosed {
                log.Fatal(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "flag"
        "log"
        "net"

        "github.com/pkg/errors"
        "google.golang.org/grpc"

        conf "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/config"

        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/postgresqlx"

        orderHandler "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/order/delivery/grpc"
        orderRepo "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/order/repository"
        orderUcase "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/order/usecase"

        orderProto "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/order/proto"
)

func main() <span class="cov0" title="0">{
        configPath := flag.String("config", "../../config/order.toml", "path to config file")
        flag.Parse()

        config := conf.NewOrderMicroserviceConfig()
        err := conf.ReadConfigFile(*configPath, config)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(errors.Wrap(err, "error reading config"))
        }</span>

        <span class="cov0" title="0">pgxManager, err := postgresqlx.NewPostgresqlX(&amp;config.DatabaseConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(errors.Wrap(err, "error creating postgres agent"))
        }</span>
        <span class="cov0" title="0">defer pgxManager.Close()

        orderRepo := orderRepo.NewOrderRepo(pgxManager)

        orderUcase := orderUcase.NewOrderUcase(orderRepo)

        orderHandler := orderHandler.NewOrderHandler(orderUcase)

        lis, err := net.Listen("tcp", config.OrderServConfig.BindAddr)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln("cant listen port", err)
        }</span>

        <span class="cov0" title="0">server := grpc.NewServer()

        orderProto.RegisterOrderServiceServer(server, orderHandler)

        server.Serve(lis)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package config

import (
        "time"

        "github.com/BurntSushi/toml"
)

type Config struct {
        ServConfig            ServerConfig      `toml:"server"`
        LoggerConfig          LogConfig         `toml:"logger"`
        AuthentificatorConfig AuthManagerConfig `toml:"authManager"`
        NotificatorConfig     NotificatorConfig `toml:"notificator"`
        CacherConfig          CachConfig        `toml:"cacher"`
        DatabaseConfig        DatabaseConfig    `toml:"database"`
        CorsConfig            CorsConfig        `toml:"cors"`
        CsrfConfig            CsrfConfig        `toml:"csrf"`
        AuthMicroserverAddr   string            `toml:"authMicroserviceAddr"`
        OrderMicroserverAddr  string            `toml:"orderMicroserviceAddr"`
}

type AuthMicroserviceConfig struct {
        AuthServConfig        AuthServerConfig  `toml:"server"`
        AuthentificatorConfig AuthManagerConfig `toml:"authManager"`
        NotificatorConfig     NotificatorConfig `toml:"notificator"`
        CacherConfig          CachConfig        `toml:"cacher"`
        DatabaseConfig        DatabaseConfig    `toml:"database"`
}

type AuthServerConfig struct {
        BindAddr string `toml:"bindAddr"`
}

type OrderMicroserviceConfig struct {
        OrderServConfig OrderServerConfig `toml:"server"`
        DatabaseConfig  DatabaseConfig    `toml:"database"`
}

type OrderServerConfig struct {
        BindAddr string `toml:"bindAddr"`
}

type ServerConfig struct {
        BindAddr     string `toml:"bindAddr"`
        ReadTimeout  int    `toml:"readTimeout"`
        WriteTimeout int    `toml:"writeTimeout"`
        StaticUrl    string `toml:"staticUrl"`
        StaticPath   string `toml:"staticPath"`
}

type LogConfig struct {
        Level            string
        Encoding         string
        OutputPaths      []string
        ErrorOutputPaths []string

        MessageKey    string
        TimeKey       string
        LevelKey      string
        NameKey       string
        FunctionKey   string
        StacktraceKey string
}

type CachConfig struct {
        Host string
        Port int
}

type AuthManagerConfig struct {
        Key        string
        Method     string
        ExpiryTime duration
}
type duration struct {
        time.Duration
}

func (d *duration) UnmarshalText(text []byte) error <span class="cov0" title="0">{
        var err error
        d.Duration, err = time.ParseDuration(string(text))
        return err
}</span>

type NotificatorConfig struct {
        ApiKey string
        Email  string
}

type DatabaseConfig struct {
        DbName        string
        User          string
        Password      string
        Port          int
        Host          string
        ConnectionMax int
}

type CorsConfig struct {
        AllowOrigins []string `toml:"allowOrigins"`
        MaxAge       int      `toml:"maxAge"`
}

type CsrfConfig struct {
        MaxAge int `toml:"maxAge"`
}

func NewConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{}
}</span>

func NewAuthMicroserviceConfig() *AuthMicroserviceConfig <span class="cov0" title="0">{
        return &amp;AuthMicroserviceConfig{}
}</span>

func NewOrderMicroserviceConfig() *OrderMicroserviceConfig <span class="cov0" title="0">{
        return &amp;OrderMicroserviceConfig{}
}</span>

func ReadConfigFile(configPath string, dst interface{}) error <span class="cov0" title="0">{
        _, err := toml.DecodeFile(configPath, dst)
        return err
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package configRouting

import (
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/config"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/delivery/http/middleware"
        "github.com/labstack/echo/v4"
        echoMiddleware "github.com/labstack/echo/v4/middleware"
)

func ConfigureCommonMiddleware(router *echo.Echo, mwChain *middleware.CommonMiddlewareChain, corsCfg *config.CorsConfig, csrfCfg *config.CsrfConfig) <span class="cov0" title="0">{
        router.HTTPErrorHandler = mwChain.ErrorHandler
        router.Use(mwChain.PanicMiddleware)
        router.Use(mwChain.RequestIdMiddleware)
        router.Use(mwChain.AccessLogMiddleware)
        router.Use(mwChain.AuthMiddleware)
        router.Use(echoMiddleware.CORSWithConfig(getCorsConfig(corsCfg)))
        router.Use(middleware.CSRFWithConfig(getCsrfConfig(csrfCfg)))
        router.Use(middleware.CsrfSetHeader)
        //router.Use(middleware.)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package configRouting

import (
        _ "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/docs"
        suggestHandler "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/address/delivery/http"
        commentHandler "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/comments/delivery/http"
        dishesHandler "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/dishes/delivery/http"
        orderHandler "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/order/delivery/http"
        restaurantsHandler "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/restaurants/delivery/http"
        userHandler "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/user/delivery/http"
        "github.com/labstack/echo/v4"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        // echoSwagger "github.com/swaggo/echo-swagger"
)

type ServerHandlers struct {
        UserHandler        *userHandler.UserHandler
        RestaurantsHandler *restaurantsHandler.RestaurantsHandler
        DishesHandler      *dishesHandler.DishesHandler
        SuggsHandler       *suggestHandler.SuggsHandler
        OrderHandler       *orderHandler.OrderHandler
        CommentsHandler    *commentHandler.CommentsHandler

}

const (
        v1Prefix = "/api/v1/"
)

// TODO:  убрать миддлвар авторизации с suggests
func (sh *ServerHandlers) ConfigureRouting(router *echo.Echo) <span class="cov0" title="0">{
        router.GET("metrics", echo.WrapHandler(promhttp.Handler()))
        router.Static("/static", "static")
        //router.GET("/swagger/*", echoSwagger.WrapHandler)
        router.POST(v1Prefix+"login", sh.UserHandler.Login)
        router.GET(v1Prefix+"logout", sh.UserHandler.Logout)
        router.POST(v1Prefix+"register", sh.UserHandler.Register)
        // router.POST(v1Prefix+"update", sh.UserHandler.UpdateUser)
        router.POST(v1Prefix+"update", sh.UserHandler.UpdateUser)
        router.POST(v1Prefix+"send_code", sh.UserHandler.SendCode)
        router.GET(v1Prefix+"user", sh.UserHandler.GetUser)
        router.GET(v1Prefix+"suggest", sh.SuggsHandler.Suggest)
        router.POST(v1Prefix+"order", sh.OrderHandler.CreateOrder)
        router.GET(v1Prefix+"orders", sh.OrderHandler.GetUserOrders)
        router.GET(v1Prefix+"order_statuses", sh.OrderHandler.GetUserOrderStatuses)
        router.GET(v1Prefix+"order/:orderId", sh.OrderHandler.GetUserOrder)

        router.GET(v1Prefix+"comments/:slug", sh.CommentsHandler.GetRestaurantComments)
        router.POST(v1Prefix+"comment", sh.CommentsHandler.AddRestaurantComment)
        router.GET(v1Prefix+"restaurants", sh.RestaurantsHandler.GetAllRestaurantsMain)
        router.GET(v1Prefix+"", sh.RestaurantsHandler.GetAllRestaurants)
        router.GET(v1Prefix+"restaurant/:slug", sh.DishesHandler.GetDishesByRestaurants)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package configRouting

import (
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/config"
        "github.com/labstack/echo/v4"
        "github.com/labstack/echo/v4/middleware"
)

/*
        AllowedHeaders: []string{"access-control-allow-origin", "content-type",
                "x-csrf-token", "access-control-expose-headers"},
*/

func getCorsConfig(cfg *config.CorsConfig) middleware.CORSConfig <span class="cov0" title="0">{
        // TODO: это все заголовки?
        return middleware.CORSConfig{
                AllowOrigins:     cfg.AllowOrigins,
                AllowCredentials: true,
                AllowHeaders:     []string{echo.HeaderOrigin, echo.HeaderContentType, echo.HeaderAccept, echo.HeaderXCSRFToken},
                AllowMethods:     []string{echo.GET, echo.POST, echo.OPTIONS, echo.PUT},
                ExposeHeaders:    []string{echo.HeaderXCSRFToken},
                MaxAge:           cfg.MaxAge,
        }
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package configRouting

import (
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/config"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/delivery/http/middleware"
        "github.com/labstack/echo/v4"

        userHandler "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/user/delivery/http"
)

func getCsrfConfig(cfg *config.CsrfConfig) middleware.CSRFConfig <span class="cov0" title="0">{
        return middleware.CSRFConfig{
                CookieMaxAge: cfg.MaxAge,
                Skipper: func(context echo.Context) bool </span><span class="cov0" title="0">{
                        if context.Request().RequestURI == v1Prefix+"send_code" ||
                                context.Request().RequestURI == v1Prefix+"suggest" </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        <span class="cov0" title="0">return false</span>
                },
                SetterTokenInUnsafeMethod: func(context echo.Context) bool <span class="cov0" title="0">{
                        if context.Request().RequestURI == v1Prefix+"login" ||
                                context.Request().RequestURI == v1Prefix+"register" </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        <span class="cov0" title="0">return false</span>
                },
                CookieName: userHandler.CSRFCookieName,
                CookiePath: "/",
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package docs GENERATED BY SWAG; DO NOT EDIT
// This file was generated by swaggo/swag
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {
            "name": "API Support",
            "url": "http://www.swagger.io/support",
            "email": "support@swagger.io"
        },
        "license": {
            "name": "Apache 2.0",
            "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/comment": {
            "post": {
                "description": "Add comments by restaurant",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Comments"
                ],
                "summary": "Add comments by restaurant",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.CommentDataDelivery"
                        }
                    }
                }
            }
        },
        "/comments/:id": {
            "get": {
                "description": "get comments by restaurant",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Comments"
                ],
                "summary": "List comments by restaurant",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.CommentsDataDelivery"
                        }
                    }
                }
            }
        },
        "/restaurant/:slug": {
            "get": {
                "description": "get dishes by restaurant",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Restaurants"
                ],
                "summary": "List dishes by restaurant",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.RestaurantsDishesJsonForKirill"
                        }
                    }
                }
            }
        },
        "/restaurants": {
            "get": {
                "description": "Get restaurants",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Restaurants"
                ],
                "summary": "List restaurants",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.RestaurantJsonForKirill"
                            }
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "models.CommentDataDelivery": {
            "type": "object",
            "properties": {
                "commentRating": {
                    "type": "integer"
                },
                "commentText": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "restaurants": {
                    "type": "integer"
                },
                "userId": {
                    "type": "integer"
                }
            }
        },
        "models.CommentsDataDelivery": {
            "type": "object",
            "properties": {
                "comment": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.CommentDataDelivery"
                    }
                }
            }
        },
        "models.DishJsonForKirill": {
            "type": "object",
            "properties": {
                "description": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "imgPath": {
                    "type": "string"
                },
                "info": {
                    "type": "integer"
                },
                "price": {
                    "type": "integer"
                },
                "productName": {
                    "type": "string"
                },
                "restaurany": {
                    "type": "integer"
                },
                "weight": {
                    "type": "integer"
                }
            }
        },
        "models.RestaurantJsonForKirill": {
            "type": "object",
            "properties": {
                "address": {
                    "type": "string"
                },
                "city": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "imgPath": {
                    "type": "string"
                },
                "min_price": {
                    "type": "integer"
                },
                "price": {
                    "type": "integer"
                },
                "rating": {
                    "type": "number"
                },
                "restName": {
                    "type": "string"
                },
                "slug": {
                    "type": "string"
                },
                "timeToDeliver": {
                    "type": "string"
                }
            }
        },
        "models.RestaurantsDishesJsonForKirill": {
            "type": "object",
            "properties": {
                "address": {
                    "type": "string"
                },
                "avgPrice": {
                    "type": "integer"
                },
                "city": {
                    "type": "string"
                },
                "dishes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.DishJsonForKirill"
                    }
                },
                "id": {
                    "type": "integer"
                },
                "imgPath": {
                    "type": "string"
                },
                "minPrice": {
                    "type": "integer"
                },
                "rating": {
                    "type": "number"
                },
                "restName": {
                    "type": "string"
                },
                "slug": {
                    "type": "string"
                },
                "timeToDeliver": {
                    "type": "string"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8080",
        BasePath:         "/api/v1",
        Schemes:          []string{},
        Title:            "Swagger Example API",
        Description:      "This is a sample server celler server.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
}

func init() <span class="cov8" title="1">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package suggestHandler

import (
        "net/http"

        "github.com/asaskevich/govalidator"
        addr "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/address"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/delivery/http/httpErrDescr"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/delivery/http/middleware"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/models"
        _ "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/validator"
        "github.com/labstack/echo/v4"
)

type SuggsHandler struct {
        Ucase addr.Ucase
}

func NewSuggsHandler(ucase addr.Ucase) *SuggsHandler <span class="cov8" title="1">{
        return &amp;SuggsHandler{
                Ucase: ucase,
        }
}</span>

func (h SuggsHandler) Suggest(ctx echo.Context) error <span class="cov8" title="1">{
        logger := middleware.GetLoggerFromCtx(ctx)
        requestId := middleware.GetRequestIdFromCtx(ctx)
        var suggsReq models.SuggestReq
        suggsReq.Address = ctx.QueryParam("q")
        if _, err := govalidator.ValidateStruct(suggsReq); err != nil </span><span class="cov8" title="1">{
                return httpErrDescr.NewHTTPError(ctx, http.StatusBadRequest, httpErrDescr.INVALID_DATA)
        }</span>

        <span class="cov8" title="1">suggsResp, err := h.Ucase.Suggest(&amp;models.SuggestUcaseReq{Address: suggsReq.Address})

        if err != nil </span><span class="cov8" title="1">{
                logger.Error(requestId, err.Error())
                return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)
        }</span>

        <span class="cov8" title="1">return ctx.JSON(http.StatusOK, models.SuggestResp{AddressFull: suggsResp.AddressFull, Suggests: suggsResp.Suggests})</span>

}
</pre>
		
		<pre class="file" id="file10" style="display: none">package mock

import (
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/models"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/servErrors"
        "github.com/stretchr/testify/mock"
)

type AddrRepo struct {
        mock.Mock
}

func (r *AddrRepo) SuggestStreet(address *models.SuggestStreetRepoInput) (*models.SuggestStreetRepoAnsw, error) <span class="cov8" title="1">{
        return &amp;models.SuggestStreetRepoAnsw{StreetSuggests: []string{"Измайловская улица", "Измайловский проспект"}}, nil
}</span>

func (r *AddrRepo) SuggestHouse(addres *models.SuggestHouseRepoInput) (*models.SuggestHouseRepoAnsw, error) <span class="cov0" title="0">{
        return &amp;models.SuggestHouseRepoAnsw{HouseSuggests: []string{"1"}}, nil
}</span>

func (r *AddrRepo) GetCity(city string) (*models.GetCityRepoAnsw, error) <span class="cov8" title="1">{
        return &amp;models.GetCityRepoAnsw{CityId: 1, Name: "Москва"}, nil
}</span>

func (r *AddrRepo) GetStreet(street *models.GetStreetRepoInput) (*models.GetStreetRepoAnsw, error) <span class="cov8" title="1">{
        return &amp;models.GetStreetRepoAnsw{StreetId: 1, Name: "Измайловский проспект"}, nil
}</span>

func (r *AddrRepo) GetHouse(house *models.GetHouseRepoInput) (*models.GetHouseRepoAnsw, error) <span class="cov8" title="1">{
        return &amp;models.GetHouseRepoAnsw{House: "1"}, nil
}</span>

type AddrRepoErr struct {
        mock.Mock
}

func (r *AddrRepoErr) SuggestStreet(address *models.SuggestStreetRepoInput) (*models.SuggestStreetRepoAnsw, error) <span class="cov0" title="0">{
        return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, "")
}</span>

func (r *AddrRepoErr) SuggestHouse(addres *models.SuggestHouseRepoInput) (*models.SuggestHouseRepoAnsw, error) <span class="cov0" title="0">{
        return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, "")
}</span>

func (r *AddrRepoErr) GetCity(city string) (*models.GetCityRepoAnsw, error) <span class="cov8" title="1">{
        return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, "")
}</span>

func (r *AddrRepoErr) GetStreet(street *models.GetStreetRepoInput) (*models.GetStreetRepoAnsw, error) <span class="cov0" title="0">{
        return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, "")
}</span>

func (r *AddrRepoErr) GetHouse(house *models.GetHouseRepoInput) (*models.GetHouseRepoAnsw, error) <span class="cov0" title="0">{
        return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, "")
}</span>

type AddrRepoHouseErr struct {
        mock.Mock
}

func (r *AddrRepoHouseErr) SuggestHouse(addres *models.SuggestHouseRepoInput) (*models.SuggestHouseRepoAnsw, error) <span class="cov8" title="1">{
        return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, "")
}</span>

func (r *AddrRepoHouseErr) GetHouse(house *models.GetHouseRepoInput) (*models.GetHouseRepoAnsw, error) <span class="cov8" title="1">{
        return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, "")
}</span>

func (r *AddrRepoHouseErr) SuggestStreet(address *models.SuggestStreetRepoInput) (*models.SuggestStreetRepoAnsw, error) <span class="cov0" title="0">{
        return &amp;models.SuggestStreetRepoAnsw{StreetSuggests: []string{"Измайловская улица", "Измайловский проспект"}}, nil
}</span>

func (r *AddrRepoHouseErr) GetCity(city string) (*models.GetCityRepoAnsw, error) <span class="cov8" title="1">{
        return &amp;models.GetCityRepoAnsw{CityId: 1, Name: "Москва"}, nil
}</span>

func (r *AddrRepoHouseErr) GetStreet(street *models.GetStreetRepoInput) (*models.GetStreetRepoAnsw, error) <span class="cov8" title="1">{
        return &amp;models.GetStreetRepoAnsw{StreetId: 1, Name: "Измайловский проспект"}, nil
}</span>

type AddrRepoGetHouseErr struct {
        mock.Mock
}

func (r *AddrRepoGetHouseErr) SuggestHouse(addres *models.SuggestHouseRepoInput) (*models.SuggestHouseRepoAnsw, error) <span class="cov8" title="1">{
        return &amp;models.SuggestHouseRepoAnsw{HouseSuggests: []string{"1"}}, nil
}</span>

func (r *AddrRepoGetHouseErr) GetHouse(house *models.GetHouseRepoInput) (*models.GetHouseRepoAnsw, error) <span class="cov8" title="1">{
        return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, "")
}</span>

func (r *AddrRepoGetHouseErr) SuggestStreet(address *models.SuggestStreetRepoInput) (*models.SuggestStreetRepoAnsw, error) <span class="cov0" title="0">{
        return &amp;models.SuggestStreetRepoAnsw{StreetSuggests: []string{"Измайловская улица", "Измайловский проспект"}}, nil
}</span>

func (r *AddrRepoGetHouseErr) GetCity(city string) (*models.GetCityRepoAnsw, error) <span class="cov8" title="1">{
        return &amp;models.GetCityRepoAnsw{CityId: 1, Name: "Москва"}, nil
}</span>

func (r *AddrRepoGetHouseErr) GetStreet(street *models.GetStreetRepoInput) (*models.GetStreetRepoAnsw, error) <span class="cov8" title="1">{
        return &amp;models.GetStreetRepoAnsw{StreetId: 1, Name: "Измайловский проспект"}, nil
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package mock

import (
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/models"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/servErrors"
        "github.com/stretchr/testify/mock"
)

type AddrUcase struct {
        mock.Mock
}

func (s AddrUcase) Suggest(req *models.SuggestUcaseReq) (*models.SuggestUcaseResp, error) <span class="cov8" title="1">{
        return &amp;models.SuggestUcaseResp{AddressFull: false, Suggests: []string{"Москва, Тверская улица, 12"}}, nil
}</span>

type AddrUcaseErr struct {
        mock.Mock
}

func (s AddrUcaseErr) Suggest(req *models.SuggestUcaseReq) (*models.SuggestUcaseResp, error) <span class="cov8" title="1">{
        return &amp;models.SuggestUcaseResp{}, servErrors.NewError(servErrors.DB_ERROR, "")
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package repository

import (
        "database/sql"
        "strings"

        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/models"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/servErrors"
        "github.com/jmoiron/sqlx"
)

const (
        suggsLimit = 5
)

type AddrRepo struct {
        DB *sqlx.DB
}

func NewAddrRepo(db *sqlx.DB) *AddrRepo <span class="cov8" title="1">{
        return &amp;AddrRepo{DB: db}
}</span>

// user := &amp;models.UserDataStorage{}
//         err := r.DB.Get(user, `SELECT id, phone, email, name FROM users WHERE phone = $1`, phone)
//         switch err {
//         case nil:
//                 return user, nil
//         case sql.ErrNoRows:
//                 return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, err.Error())
//         default:
//                 return nil, servErrors.NewError(servErrors.DB_ERROR, err.Error())
//         }
// items := make([]*Item, 0, 10)
// err := repo.DB.Select(&amp;items, "SELECT id, title, updated FROM items")

func (r *AddrRepo) SuggestStreet(address *models.SuggestStreetRepoInput) (*models.SuggestStreetRepoAnsw, error) <span class="cov8" title="1">{
        // suggs := make([]*[]rune, 0, suggsLimit)
        suggs := make([]*string, 0, suggsLimit)
        // err := repo.DB.Select(&amp;items, "SELECT id, title, updated FROM items")
        // var suggs []string
        err := r.DB.Select(&amp;suggs, `SELECT name FROM streets WHERE name ILIKE $1 LIMIT $2`, address.Street+"%", suggsLimit)
        // err := r.DB.Select(&amp;suggs, `SELECT name FROM msc_streets WHERE name ILIKE $1 LIMIT $2`, "%"+"Измайл"+"%", suggsLimit)
        // fmt.Println(suggs)
        // fmt.Println(err)
        // fmt.Println(len(suggs))
        switch err </span>{
        case nil:<span class="cov8" title="1">
                if len(suggs) == 0 </span><span class="cov0" title="0">{
                        return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, "")
                }</span>
                <span class="cov8" title="1">suggsRepo := make([]string, len(suggs))
                for i := 0; i &lt; suggsLimit &amp;&amp; i &lt; len(suggs) &amp;&amp; (suggs[i]) != nil; i++ </span><span class="cov8" title="1">{
                        suggsRepo[i] = *suggs[i]
                }</span>
                <span class="cov8" title="1">return &amp;models.SuggestStreetRepoAnsw{StreetSuggests: suggsRepo}, nil</span>
        case sql.ErrNoRows:<span class="cov8" title="1">
                return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, err.Error())</span>
        default:<span class="cov8" title="1">
                return nil, servErrors.NewError(servErrors.DB_ERROR, err.Error())</span>
        }
}

func (r *AddrRepo) SuggestHouse(address *models.SuggestHouseRepoInput) (*models.SuggestHouseRepoAnsw, error) <span class="cov8" title="1">{
        suggs := make([]*string, 0, suggsLimit)

        err := r.DB.Select(&amp;suggs, `SELECT house FROM houses WHERE street_id =$1 AND house ILIKE $2  LIMIT $3`, address.StreetId, address.House+"%", suggsLimit)
        // fmt.Println(suggs)
        // fmt.Println(err)
        // fmt.Println(len(suggs))
        switch err </span>{
        case nil:<span class="cov8" title="1">
                if len(suggs) == 0 </span><span class="cov0" title="0">{
                        return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, "")
                }</span>
                <span class="cov8" title="1">suggsRepo := make([]string, len(suggs))
                for i := 0; i &lt; suggsLimit &amp;&amp; i &lt; len(suggs) &amp;&amp; (suggs[i]) != nil; i++ </span><span class="cov8" title="1">{
                        suggsRepo[i] = *suggs[i]
                }</span>
                <span class="cov8" title="1">return &amp;models.SuggestHouseRepoAnsw{HouseSuggests: suggsRepo}, nil</span>
        case sql.ErrNoRows:<span class="cov8" title="1">
                return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, err.Error())</span>
        default:<span class="cov8" title="1">
                return nil, servErrors.NewError(servErrors.DB_ERROR, err.Error())</span>
        }
}

func (r *AddrRepo) GetCity(city string) (*models.GetCityRepoAnsw, error) <span class="cov8" title="1">{
        if strings.ToLower(city) == "москва" </span><span class="cov8" title="1">{
                return &amp;models.GetCityRepoAnsw{CityId: 0, Name: "Москва"}, nil
        }</span>
        <span class="cov8" title="1">return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, "")</span>
}

func (r *AddrRepo) GetStreet(street *models.GetStreetRepoInput) (*models.GetStreetRepoAnsw, error) <span class="cov8" title="1">{
        streetAnsw := &amp;models.GetStreetRepoAnsw{}
        err := r.DB.Get(streetAnsw, `SELECT id as streetid, name FROM streets WHERE name ILIKE $1`, street.Street)
        switch err </span>{
        case nil:<span class="cov8" title="1">
                return streetAnsw, nil</span>
        case sql.ErrNoRows:<span class="cov8" title="1">
                return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, err.Error())</span>
        default:<span class="cov8" title="1">
                return nil, servErrors.NewError(servErrors.DB_ERROR, err.Error())</span>
        }
}

func (r *AddrRepo) GetHouse(house *models.GetHouseRepoInput) (*models.GetHouseRepoAnsw, error) <span class="cov8" title="1">{
        houseAnsw := &amp;models.GetHouseRepoAnsw{}
        err := r.DB.Get(houseAnsw, `SELECT house FROM houses WHERE street_id =$1 AND house ILIKE $2`, house.StreetId, house.House)
        switch err </span>{
        case nil:<span class="cov8" title="1">
                return houseAnsw, nil</span>
        case sql.ErrNoRows:<span class="cov8" title="1">
                return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, err.Error())</span>
        default:<span class="cov8" title="1">
                return nil, servErrors.NewError(servErrors.DB_ERROR, err.Error())</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package ucase

import (
        "regexp"
        "strings"
        "unicode/utf8"

        "github.com/pkg/errors"

        addr "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/address"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/models"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/servErrors"
)

type AddrUcase struct {
        AddrRepo      addr.Repository
        replaceRegexp regexp.Regexp
}

func NewAddrUcase(repo addr.Repository) *AddrUcase <span class="cov8" title="1">{
        return &amp;AddrUcase{
                AddrRepo:      repo,
                replaceRegexp: *regexp.MustCompile(toDeleteRegexp),
        }
}</span>

const (
        city = iota
        street
        house
        ready

        toDeleteRegexp = `^ *гор\.|^ *гор |^ *г |^ *г\.|^ *город | ул\.| ул | дом | д.| д `
        separator      = ","
)

var defaultRes = []string{"Москва, ", "Москва, Бауманская Улица, ", "Москва, Тверская Улица, "}

type addressT struct {
        city       string
        street     string
        house      string
        toComplite int
}

func (u *AddrUcase) parseAddress(addrStr string) *addressT <span class="cov8" title="1">{
        addrStr = string(u.replaceRegexp.ReplaceAll([]byte(addrStr), []byte(" ")))
        addrParts := strings.Split(addrStr, separator)
        for i := range addrParts </span><span class="cov8" title="1">{
                addrParts[i] = strings.TrimSpace(addrParts[i])
        }</span>
        <span class="cov8" title="1">switch len(addrParts) - 1 </span>{
        case 0:<span class="cov8" title="1">
                return &amp;addressT{
                        toComplite: city,
                }</span>
        case 1:<span class="cov8" title="1">
                return &amp;addressT{
                        street:     addrParts[0],
                        toComplite: street,
                }</span>
        // case 2:
        //         return &amp;addressT{
        //                 city:       addrParts[0],
        //                 street:     addrParts[1],
        //                 toComplite: street,
        //         }

        default:<span class="cov8" title="1">
                return &amp;addressT{
                        city:       addrParts[0],
                        street:     addrParts[1],
                        house:      addrParts[2],
                        toComplite: house,
                }</span>
        }
}

func (u *AddrUcase) suggestCity() (*models.SuggestUcaseResp, error) <span class="cov8" title="1">{
        return &amp;models.SuggestUcaseResp{Suggests: defaultRes}, nil
}</span>

func (u *AddrUcase) suggestStreet(address addressT) (*models.SuggestUcaseResp, error) <span class="cov8" title="1">{
        city, err := u.AddrRepo.GetCity(address.city)
        if err != nil </span><span class="cov8" title="1">{
                cause := servErrors.ErrorAs(err)
                switch </span>{
                case cause == nil:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                return nil, errors.Wrap(err, "unexpected error")
                        }</span>
                case cause.Code == servErrors.NO_SUCH_ENTITY_IN_DB:<span class="cov8" title="1">
                        </span><span class="cov8" title="1">{
                                return u.suggestCity()
                        }</span>
                default:<span class="cov0" title="0">
                        return nil, errors.Wrap(err, "error getting city from db")</span>
                }
        }
        <span class="cov8" title="1">var suggs *models.SuggestStreetRepoAnsw

        pozToCut := len(address.street)
        for i := 0; i &lt; 3 &amp;&amp; suggs == nil &amp;&amp; pozToCut &gt;= 0; i++ </span><span class="cov8" title="1">{

                street := []rune(address.street[:(pozToCut)])
                suggs, err = u.AddrRepo.SuggestStreet(&amp;models.SuggestStreetRepoInput{Street: string(street)})
                if len(address.street)-i*3 &lt;= 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">pozToCut--
                for j := 0; j &lt; 2 &amp;&amp; pozToCut &gt;= 0; pozToCut-- </span><span class="cov8" title="1">{
                        if utf8.ValidString(address.street[pozToCut:]) </span><span class="cov8" title="1">{
                                j++
                        }</span>
                }
                <span class="cov8" title="1">pozToCut++</span>
        }
        <span class="cov8" title="1">if suggs == nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "error suggesting street")
        }</span>
        <span class="cov8" title="1">var suggsResp models.SuggestUcaseResp
        for _, addr := range suggs.StreetSuggests </span><span class="cov8" title="1">{
                suggsResp.Suggests = append(suggsResp.Suggests, city.Name+separator+" "+addr+", ")
        }</span>
        <span class="cov8" title="1">return &amp;suggsResp, err</span>
}

func (u *AddrUcase) suggestHouse(address addressT) (*models.SuggestUcaseResp, error) <span class="cov8" title="1">{
        city, err := u.AddrRepo.GetCity(address.city)
        if err != nil </span><span class="cov0" title="0">{
                cause := servErrors.ErrorAs(err)
                switch </span>{
                case cause == nil:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                return nil, errors.Wrap(err, "unexpected error")
                        }</span>
                case cause.Code == servErrors.NO_SUCH_ENTITY_IN_DB:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                return u.suggestCity()
                        }</span>
                default:<span class="cov0" title="0">
                        return nil, errors.Wrap(err, "error getting city from db")</span>
                }
        }
        <span class="cov8" title="1">street, err := u.AddrRepo.GetStreet(&amp;models.GetStreetRepoInput{Street: address.street, CityId: city.CityId})
        if err != nil </span><span class="cov0" title="0">{
                cause := servErrors.ErrorAs(err)
                switch </span>{
                case cause == nil:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                return nil, errors.Wrap(err, "unexpected error")
                        }</span>
                case cause.Code == servErrors.NO_SUCH_ENTITY_IN_DB:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                return u.suggestStreet(address)
                        }</span>
                default:<span class="cov0" title="0">
                        return nil, errors.Wrap(err, "error getting street from db")</span>
                }
        }

        <span class="cov8" title="1">house, err := u.AddrRepo.GetHouse(&amp;models.GetHouseRepoInput{StreetId: street.StreetId, House: address.house})
        if err == nil &amp;&amp; house != nil &amp;&amp; house.House != "" </span><span class="cov8" title="1">{
                return &amp;models.SuggestUcaseResp{Suggests: []string{city.Name + separator + " " + street.Name + ", " + house.House}, AddressFull: true}, nil
        }</span>

        <span class="cov8" title="1">var suggs *models.SuggestHouseRepoAnsw
        pozToCut := len(address.house)
        for i := 0; i &lt; 3 &amp;&amp; suggs == nil &amp;&amp; pozToCut &gt;= 0; i++ </span><span class="cov8" title="1">{

                house := []rune(address.house[:pozToCut])
                // fmt.Println(string(house))
                suggs, err = u.AddrRepo.SuggestHouse(&amp;models.SuggestHouseRepoInput{StreetId: street.StreetId, House: string(house)})
                if len(address.house)-i*1 &lt;= 0 </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">for pozToCut--; !utf8.ValidString(address.house[pozToCut:]) &amp;&amp; pozToCut &gt;= 0; pozToCut-- </span>{<span class="cov0" title="0">
                }</span>
        }
        <span class="cov8" title="1">if suggs == nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, "error suggesting house")
        }</span>
        <span class="cov8" title="1">var suggsResp models.SuggestUcaseResp
        for _, house := range suggs.HouseSuggests </span><span class="cov8" title="1">{
                suggsResp.Suggests = append(suggsResp.Suggests, city.Name+separator+" "+street.Name+", "+house)
        }</span>
        <span class="cov8" title="1">suggsResp.AddressFull = true
        return &amp;suggsResp, err</span>
}

func (u *AddrUcase) Suggest(address *models.SuggestUcaseReq) (*models.SuggestUcaseResp, error) <span class="cov8" title="1">{
        if address == nil </span><span class="cov8" title="1">{
                return u.suggestCity()
        }</span>
        <span class="cov8" title="1">addr := u.parseAddress(address.Address)
        if addr == nil </span><span class="cov0" title="0">{
                return u.suggestCity()
        }</span>
        <span class="cov8" title="1">switch addr.toComplite </span>{
        case street:<span class="cov8" title="1">
                </span><span class="cov8" title="1">{
                        return u.suggestStreet(*addr)
                }</span>
        case house:<span class="cov8" title="1">
                </span><span class="cov8" title="1">{
                        return u.suggestHouse(*addr)
                }</span>
        default:<span class="cov8" title="1">
                return u.suggestCity()</span>
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package restaurantsHandler

import (
        "encoding/json"
        "net/http"
        "strconv"

        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/comments"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/delivery/http/httpErrDescr"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/delivery/http/middleware"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/models"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/servErrors"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/staticManager"
        "github.com/labstack/echo/v4"
)

type CommentsHandler struct {
        Ucase         comments.Ucase
        StaticManager staticManager.FileManager
}

func NewCommentsHandler(ucase comments.Ucase) *CommentsHandler <span class="cov0" title="0">{
        return &amp;CommentsHandler{
                Ucase: ucase,
        }
}</span>

// GetRestaurantComments Get comments by restaurant godoc
// @Summary      List comments by restaurant
// @Description  get comments by restaurant
// @Tags         Comments
// @Accept       json
// @Produce      json
// @Success      200  {object}   models.CommentsDataDelivery
// @Router       /comments/:id [get]
func (h CommentsHandler) GetRestaurantComments(ctx echo.Context) error <span class="cov0" title="0">{
        logger := middleware.GetLoggerFromCtx(ctx)
        requestId := middleware.GetRequestIdFromCtx(ctx)

        //item := ctx.Param("id")
        //id, err := strconv.ParseInt(item, 16, 32)
        slug := ctx.Param("slug")

        commetsDataDelivery, err := h.Ucase.GetRestaurantComments(slug)

        if err != nil </span><span class="cov0" title="0">{
                cause := servErrors.ErrorAs(err)
                if cause != nil &amp;&amp; cause.Code == servErrors.NO_SUCH_ENTITY_IN_DB </span><span class="cov0" title="0">{
                        return httpErrDescr.NewHTTPError(ctx, http.StatusForbidden, httpErrDescr.NO_SUCH_USER)
                }</span>
                <span class="cov0" title="0">logger.Error(requestId, err.Error())
                return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)</span>
        }

        <span class="cov0" title="0">if commetsDataDelivery == nil </span><span class="cov0" title="0">{
                logger.Error(requestId, "from user-ucase-get-user returned userData==nil and err==nil, unknown error")
                return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)
        }</span>

        <span class="cov0" title="0">commentsD := &amp;models.GetCommentsDataDelivery{Comment: make([]models.GetCommentDataDelivery, len(commetsDataDelivery.Comment))}

        for i, comment := range commetsDataDelivery.Comment </span><span class="cov0" title="0">{
                commentsD.Comment[i] = models.GetCommentDataDelivery{
                        Author: comment.Author,
                        Text:   comment.Text,
                        Stars:  comment.Stars,
                        Date:   comment.Date,
                }
        }</span>

        <span class="cov0" title="0">result, _ := json.Marshal(commentsD.Comment)
        ctx.Response().Header().Add(echo.HeaderContentLength, strconv.Itoa(len(result)))
        return ctx.JSONBlob(http.StatusOK, result)</span>
}

// AddRestaurantComment Add comments by restaurant godoc
// @Summary      Add comments by restaurant
// @Description  Add comments by restaurant
// @Tags         Comments
// @Accept       json
// @Produce      json
// @Success      200  {object}   models.CommentDataDelivery
// @Router       /comment [post]
func (h CommentsHandler) AddRestaurantComment(ctx echo.Context) error <span class="cov0" title="0">{
        user := middleware.GetUserFromCtx(ctx)
        if user == nil </span><span class="cov0" title="0">{
                return ctx.JSON(http.StatusUnauthorized, httpErrDescr.AUTH_REQUIRED)
        }</span>

        <span class="cov0" title="0">logger := middleware.GetLoggerFromCtx(ctx)
        requestId := middleware.GetRequestIdFromCtx(ctx)

        var AddCommentRestaurantUcaseReq models.AddCommentRestaurant
        if err := ctx.Bind(&amp;AddCommentRestaurantUcaseReq); err != nil </span><span class="cov0" title="0">{
                return httpErrDescr.NewHTTPError(ctx, http.StatusBadRequest, httpErrDescr.BAD_REQUEST_BODY)
        }</span>

        <span class="cov0" title="0">commetsDataDelivery, err := h.Ucase.AddRestaurantComment(models.UserId(user.Id), &amp;models.AddCommentRestaurantUcase{
                Restaurant:     AddCommentRestaurantUcaseReq.Restaurant,
                Comment_text:   AddCommentRestaurantUcaseReq.Comment_text,
                Comment_rating: AddCommentRestaurantUcaseReq.Comment_rating,
        })
        if err != nil </span><span class="cov0" title="0">{
                cause := servErrors.ErrorAs(err)
                if cause == nil </span><span class="cov0" title="0">{
                        logger.Error(requestId, err.Error())
                        return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)
                }</span>
                <span class="cov0" title="0">switch cause.Code </span>{
                case servErrors.WRONG_AUTH_CODE:<span class="cov0" title="0">
                        return httpErrDescr.NewHTTPError(ctx, http.StatusForbidden, httpErrDescr.WRONG_AUTH_CODE)</span>
                case servErrors.CACH_MISS_CODE, servErrors.NO_SUCH_ENTITY_IN_DB:<span class="cov0" title="0">
                        return httpErrDescr.NewHTTPError(ctx, http.StatusNotFound, httpErrDescr.NO_SUCH_CODE_INFO)</span>
                default:<span class="cov0" title="0">
                        logger.Error(requestId, err.Error())
                        return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)</span>
                }
        }

        <span class="cov0" title="0">if commetsDataDelivery == nil </span><span class="cov0" title="0">{
                logger.Error(requestId, "from user-ucase-register returned userData==nil and err==nil, unknown error")
                return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)
        }</span>

        <span class="cov0" title="0">comment := &amp;models.CommentDataDelivery{
                Restaurant_id: commetsDataDelivery.Restaurant_id,
                Author:        commetsDataDelivery.Author,
                Text:          commetsDataDelivery.Text,
                Stars:         commetsDataDelivery.Stars,
                Date:          commetsDataDelivery.Date,
        }

        result, _ := json.Marshal(comment)
        ctx.Response().Header().Add(echo.HeaderContentLength, strconv.Itoa(len(result)))
        return ctx.JSONBlob(http.StatusOK, result)</span>
}

//func (h CommentsHandler) AddRestaurantComment(ctx echo.Context) error {
//        if middleware.GetUserFromCtx(ctx) != nil {
//                return httpErrDescr.NewHTTPError(ctx, http.StatusConflict, httpErrDescr.ALREADY_AUTHORIZED)
//        }
//
//        logger := middleware.GetLoggerFromCtx(ctx)
//        requestId := middleware.GetRequestIdFromCtx(ctx)
//
//        var AddCommentRestaurantUcaseReq models.AddCommentRestaurant
//        if err := ctx.Bind(&amp;AddCommentRestaurantUcaseReq); err != nil {
//                return httpErrDescr.NewHTTPError(ctx, http.StatusBadRequest, httpErrDescr.BAD_REQUEST_BODY)
//        }
//
//        commetsDataDelivery, err := h.Ucase.AddRestaurantComment(&amp;models.AddCommentRestaurantUcase{
//                Restaurant:     AddCommentRestaurantUcaseReq.Restaurant,
//                User_id:        AddCommentRestaurantUcaseReq.User_id,
//                Comment_text:   AddCommentRestaurantUcaseReq.Comment_text,
//                Comment_rating: AddCommentRestaurantUcaseReq.Comment_rating,
//        })
//        if err != nil {
//                cause := servErrors.ErrorAs(err)
//                if cause == nil {
//                        logger.Error(requestId, err.Error())
//                        return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)
//                }
//                switch cause.Code {
//                case servErrors.WRONG_AUTH_CODE:
//                        return httpErrDescr.NewHTTPError(ctx, http.StatusForbidden, httpErrDescr.WRONG_AUTH_CODE)
//                case servErrors.CACH_MISS_CODE, servErrors.NO_SUCH_ENTITY_IN_DB:
//                        return httpErrDescr.NewHTTPError(ctx, http.StatusNotFound, httpErrDescr.NO_SUCH_CODE_INFO)
//                default:
//                        logger.Error(requestId, err.Error())
//                        return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)
//                }
//        }
//
//        if commetsDataDelivery == nil {
//                logger.Error(requestId, "from user-ucase-register returned userData==nil and err==nil, unknown error")
//                return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)
//        }
//
//        comment := &amp;models.CommentDataDelivery{
//                Id:             commetsDataDelivery.Id,
//                Restaurant:     commetsDataDelivery.Restaurant,
//                User_id:        commetsDataDelivery.User_id,
//                Comment_text:   commetsDataDelivery.Comment_text,
//                Comment_rating: commetsDataDelivery.Comment_rating,
//        }
//
//        result, _ := json.Marshal(comment)
//        ctx.Response().Header().Add(echo.HeaderContentLength, strconv.Itoa(len(result)))
//        return ctx.JSONBlob(http.StatusOK, result)
//}
</pre>
		
		<pre class="file" id="file15" style="display: none">package repository

import (
        "database/sql"

        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/models"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/servErrors"
        "github.com/jmoiron/sqlx"
)

type CommentsRepo struct {
        DB *sqlx.DB
}

func NewCommentsRepo(db *sqlx.DB) *CommentsRepo <span class="cov0" title="0">{
        return &amp;CommentsRepo{DB: db}
}</span>

func (r *CommentsRepo) GetRestaurantByID(id int) (*models.RestaurantRepo, error) <span class="cov0" title="0">{
        restaurant := &amp;models.RestaurantRepo{}
        err := r.DB.Get(restaurant, "SELECT id, name, image_path, slug, min_price, up_time_to_delivery, down_time_to_delivery, review_count, agg_rating FROM restaurants WHERE id = $1", id)
        switch err </span>{
        case nil:<span class="cov0" title="0">
                return restaurant, nil</span>
        case sql.ErrNoRows:<span class="cov0" title="0">
                return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, err.Error())</span>
        default:<span class="cov0" title="0">
                return nil, servErrors.NewError(servErrors.DB_ERROR, err.Error())</span>
        }
}

func (r *CommentsRepo) GetRestaurantBySlug(slug string) (*models.RestaurantRepo, error) <span class="cov0" title="0">{
        restaurant := &amp;models.RestaurantRepo{}
        err := r.DB.Get(restaurant, "SELECT id, name,  image_path, slug, min_price, agg_rating, review_count, up_time_to_delivery, down_time_to_delivery FROM restaurants WHERE slug = $1", slug)
        switch err </span>{
        case nil:<span class="cov0" title="0">
                return restaurant, nil</span>
        case sql.ErrNoRows:<span class="cov0" title="0">
                return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, err.Error())</span>
        default:<span class="cov0" title="0">
                return nil, servErrors.NewError(servErrors.DB_ERROR, err.Error())</span>
        }
}

func (r *CommentsRepo) GetRestaurantComments(id int) ([]*models.CommentRestaurantDataStorage, error) <span class="cov0" title="0">{
        comments := make([]*models.CommentRestaurantDataStorage, 0)
        err := r.DB.Select(&amp;comments, `SELECT restaurant_id, author, text, stars, get_ru_date(date) date_creating FROM comments WHERE restaurant_id = $1 ORDER BY date DESC`, id)

        switch err </span>{
        case nil:<span class="cov0" title="0">
                return comments, nil</span>
        case sql.ErrNoRows:<span class="cov0" title="0">
                return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, err.Error())</span>
        default:<span class="cov0" title="0">
                return nil, servErrors.NewError(servErrors.DB_ERROR, err.Error())</span>
        }
}

func (r *CommentsRepo) GetUserById(id models.UserId) (*models.UserDataRepo, error) <span class="cov0" title="0">{
        user := &amp;models.UserDataRepo{}
        err := r.DB.Get(user, `SELECT id, phone, email, name, avatar FROM users WHERE id = $1`, id)

        switch err </span>{
        case nil:<span class="cov0" title="0">
                return user, nil</span>
        case sql.ErrNoRows:<span class="cov0" title="0">
                return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, err.Error())</span>
        default:<span class="cov0" title="0">
                return nil, servErrors.NewError(servErrors.DB_ERROR, err.Error())</span>
        }
}

func (r *CommentsRepo) AddRestaurantComment(newComment *models.AddCommentRestaurantDataStorage) (*models.CommentRestaurantDataStorage, error) <span class="cov0" title="0">{
        comment := &amp;models.CommentRestaurantDataStorage{}
        err := r.DB.Get(comment, `INSERT INTO comments (restaurant_id, author, text, stars) VALUES ($1,$2,$3,$4) RETURNING restaurant_id, author, text, stars, date_creating`, newComment.Restaurant_id, newComment.User, newComment.Comment_text, newComment.Comment_rating)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrConnDone || err == sql.ErrTxDone </span><span class="cov0" title="0">{
                        return nil, servErrors.NewError(servErrors.DB_ERROR, err.Error())
                }</span>
                <span class="cov0" title="0">return nil, servErrors.NewError(servErrors.DB_INSERT, err.Error())</span>
        }
        <span class="cov0" title="0">if comment == nil </span><span class="cov0" title="0">{
                return nil, servErrors.NewError(servErrors.DB_INSERT, "")
        }</span>
        <span class="cov0" title="0">return comment, nil</span>
}

func (r *CommentsRepo) UpdateRestaurantRating(restId int, newRestRating int, countRating int) (*models.RestaurantRepo, error) <span class="cov0" title="0">{
        restaurant := &amp;models.RestaurantRepo{}
        err := r.DB.Get(restaurant, `UPDATE restaurants SET agg_rating=$1, review_count=$2 WHERE id=$3 RETURNING id, name, image_path, slug, image_path, slug, min_price, up_time_to_delivery, down_time_to_delivery, review_count, agg_rating`, newRestRating, countRating, restId)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrConnDone || err == sql.ErrTxDone </span><span class="cov0" title="0">{
                        return nil, servErrors.NewError(servErrors.DB_ERROR, err.Error())
                }</span>
                <span class="cov0" title="0">return nil, servErrors.NewError(servErrors.DB_INSERT, err.Error())</span>
        }
        <span class="cov0" title="0">if restaurant == nil </span><span class="cov0" title="0">{
                return nil, servErrors.NewError(servErrors.DB_INSERT, "")
        }</span>
        <span class="cov0" title="0">return restaurant, nil</span>
}

//token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHBpcmVkIjoiMjAyMi0wNS0wOFQxODozNDo0OS42ODYzMzgrMDM6MDAiLCJpZCI6NH0.XhuLHltOesExgjuC1bKFo5zl5D37rLXR2JNzTyqhtJw
// _csrf=ZhSKtRBGuTj24Pgc4tdtqNHL37NUHWux
</pre>
		
		<pre class="file" id="file16" style="display: none">package ucase

import (
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/comments"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/models"
        "github.com/pkg/errors"
)

type CommentsUcase struct {
        Repository comments.Repository
}

func NewCommentsUcase(commentsRepo comments.Repository) *CommentsUcase <span class="cov0" title="0">{
        return &amp;CommentsUcase{
                Repository: commentsRepo,
        }
}</span>

func (u *CommentsUcase) GetRestaurantComments(slug string) (*models.CommentsRestaurantUcase, error) <span class="cov0" title="0">{
        restaurant := &amp;models.RestaurantRepo{}
        restaurant, err := u.Repository.GetRestaurantBySlug(slug)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "error getting restaurant")
        }</span>

        <span class="cov0" title="0">commentsData, err := u.Repository.GetRestaurantComments(restaurant.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "error getting comments")
        }</span>

        <span class="cov0" title="0">commentsUC := &amp;models.CommentsRestaurantUcase{}

        for _, comment := range commentsData </span><span class="cov0" title="0">{
                item := &amp;models.CommentRestaurantUcase{
                        Author: comment.Author,
                        Text:   comment.Text,
                        Stars:  comment.Stars,
                        Date:   comment.Date,
                }
                commentsUC.Comment = append(commentsUC.Comment, *item)
        }</span>
        <span class="cov0" title="0">return commentsUC, nil</span>
}

func (u *CommentsUcase) AddRestaurantComment(id models.UserId, item *models.AddCommentRestaurantUcase) (*models.CommentRestaurantUcase, error) <span class="cov0" title="0">{
        userData, err := u.Repository.GetUserById(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "error getting user by id %d", id)
        }</span>

        <span class="cov0" title="0">comment, err := u.Repository.AddRestaurantComment(&amp;models.AddCommentRestaurantDataStorage{
                Restaurant_id:  item.Restaurant,
                User:           userData.Name,
                Comment_text:   item.Comment_text,
                Comment_rating: item.Comment_rating,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "error adding user to storage")
        }</span>

        <span class="cov0" title="0">restaurant, err := u.Repository.GetRestaurantByID(comment.Restaurant_id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "error adding user to storage")
        }</span>

        <span class="cov0" title="0">_, err = u.Repository.UpdateRestaurantRating(comment.Restaurant_id, comment.Stars+restaurant.AggRating, restaurant.ReviewCount+1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "error adding user to storage")
        }</span>

        <span class="cov0" title="0">return &amp;models.CommentRestaurantUcase{
                Restaurant_id: comment.Restaurant_id,
                Author:        comment.Author,
                Text:          comment.Text,
                Stars:         comment.Stars,
                Date:          comment.Date,
        }, nil</span>
}

//func (u *CommentsUcase) AddRestaurantComment(item *models.AddCommentRestaurantUcase) (*models.CommentRestaurantUcase, error) {
//        comment, err := u.Repository.AddRestaurantComment(&amp;models.AddCommentRestaurantDataStorage{
//                Restaurant:     item.Restaurant,
//                User_id:        item.User_id,
//                Comment_text:   item.Comment_text,
//                Comment_rating: item.Comment_rating,
//        })
//        if err != nil {
//                return nil, errors.Wrap(err, "error adding user to storage")
//        }
//
//        restaurant, err := u.Repository.GetRestaurantByID(comment.Restaurant)
//        if err != nil {
//                return nil, errors.Wrap(err, "error adding user to storage")
//        }
//
//        _, err = u.Repository.UpdateRestaurantRating(comment.Restaurant, comment.Comment_rating+restaurant.AggRating, restaurant.ReviewCount+1)
//        if err != nil {
//                return nil, errors.Wrap(err, "error adding user to storage")
//        }
//
//        return &amp;models.CommentRestaurantUcase{
//                Id:             comment.Id,
//                Restaurant:     comment.Restaurant,
//                User_id:        comment.User_id,
//                Comment_text:   comment.Comment_text,
//                Comment_rating: comment.Comment_rating,
//        }, nil
//}
</pre>
		
		<pre class="file" id="file17" style="display: none">package httpErrDescr

import "github.com/labstack/echo/v4"

const (
        AUTH_REQUIRED                  = "для этого действия необходимо авторизоваться"
        BAD_AUTH_TOKEN                 = "невалидный токен авторизации"
        NO_SUCH_RESTAURANT             = "не существует такого ресторана"
        NO_SUCH_DISHES                 = "не существует подходящих блюд"
        NO_SUCH_RESTAURANTS            = "не существует подходящих ресторанов"
        NO_SUCH_USER                   = "не существует такого пользователя"
        THIS_ORDER_DOESNOT_BELONG_USER = "этот заказ не принадлежит текущему пользователю"
        BAD_ORDER_ID                   = "неалидный  номер заказа"
        NO_SUCH_CODE_INFO              = "не найдены данные для проверки кода пользователя"
        SUCH_USER_ALREADY_EXISTS       = "пользователь с таким телефоном или почтой уже зарегистрирован"
        BAD_REQUEST_BODY               = "неправильное тело запроса"
        BAD_IMAGE                      = "ошибка при открытии загруженной картинки"
        SERVER_ERROR                   = "ошибка на сервере"
        CREATING_ORDER                 = "такой заказ не может быть создан"
        WRONG_AUTH_CODE                = "неверный код для входа"
        INVALID_DATA                   = "переданы невалидные данные"
        ALREADY_AUTHORIZED             = "пользователь уже авторизован"
        INVALID_CSRF                   = "невалидный csrf-токен"
)

func NewHTTPError(ctx echo.Context, httpStatusCode int, descr string) error <span class="cov8" title="1">{
        ctx.Response().Status = httpStatusCode
        return echo.NewHTTPError(httpStatusCode, descr)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package middleware

import (
        "time"

        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/logger"
        "github.com/labstack/echo/v4"
)

const LoggerCtxKey = "logger"

func (mw *CommonMiddlewareChain) AccessLogMiddleware(next echo.HandlerFunc) echo.HandlerFunc <span class="cov0" title="0">{
        return func(ctx echo.Context) error </span><span class="cov0" title="0">{
                reqId := GetRequestIdFromCtx(ctx)
                ctx.Set(LoggerCtxKey, mw.Logger)
                start := time.Now()
                result := next(ctx)
                mw.Logger.Access(reqId, ctx.Request().Method, ctx.Request().RemoteAddr, ctx.Request().URL.Path, time.Since(start))
                return result
        }</span>
}

func GetLoggerFromCtx(ctx echo.Context) *logger.ServLogger <span class="cov8" title="1">{
        logger, ok := ctx.Get(LoggerCtxKey).(*logger.ServLogger)
        if !ok </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return logger</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package middleware

import (
        "github.com/asaskevich/govalidator"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/models"
        _ "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/validator"
        "github.com/labstack/echo/v4"
)

const UserCtxKey = "user"
const TokenKeyCookie = "token"

type UserCtx struct {
        Id models.UserId
}

func (mw *CommonMiddlewareChain) AuthMiddleware(next echo.HandlerFunc) echo.HandlerFunc <span class="cov0" title="0">{
        return func(ctx echo.Context) error </span><span class="cov0" title="0">{
                tokenCookie, err := ctx.Request().Cookie(TokenKeyCookie)

                if err != nil </span><span class="cov0" title="0">{
                        return next(ctx)
                }</span>

                <span class="cov0" title="0">payload, err := mw.AuthManager.ParseToken(tokenCookie.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return next(ctx)
                }</span>

                <span class="cov0" title="0">if _, err = govalidator.ValidateStruct(payload); err != nil </span><span class="cov0" title="0">{
                        return next(ctx)
                }</span>

                <span class="cov0" title="0">ctx.Set(UserCtxKey, UserCtx{Id: payload.Id})
                return next(ctx)</span>
        }
}

func GetUserFromCtx(ctx echo.Context) *UserCtx <span class="cov0" title="0">{
        user, ok := ctx.Get(UserCtxKey).(UserCtx)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;user</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package middleware

import (
        "net/http"
        "time"

        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/delivery/http/httpErrDescr"
        "github.com/labstack/echo/v4"
        "github.com/labstack/gommon/random"
)

const csrfCtxKey = "csrf"

type (
        // CSRFConfig defines the config for CSRF middleware.
        CSRFConfig struct {
                Skipper                   func(ctx echo.Context) bool
                SetterTokenInUnsafeMethod func(ctx echo.Context) bool
                TokenLength               uint8
                CookieName                string
                CookieDomain              string
                CookiePath                string
                CookieMaxAge              int
        }
)

var (
        DefaultCSRFConfig = CSRFConfig{
                Skipper:                   func(c echo.Context) bool <span class="cov0" title="0">{ return false }</span>,
                SetterTokenInUnsafeMethod: func(c echo.Context) bool <span class="cov0" title="0">{ return false }</span>,
                TokenLength:               32,
                CookieName:                "_csrf",
                CookieMaxAge:              86400,
        }
)

func CSRF() echo.MiddlewareFunc <span class="cov0" title="0">{
        c := DefaultCSRFConfig
        return CSRFWithConfig(c)
}</span>

func CSRFWithConfig(config CSRFConfig) echo.MiddlewareFunc <span class="cov0" title="0">{
        if config.Skipper == nil </span><span class="cov0" title="0">{
                config.Skipper = DefaultCSRFConfig.Skipper
        }</span>
        <span class="cov0" title="0">if config.TokenLength == 0 </span><span class="cov0" title="0">{
                config.TokenLength = DefaultCSRFConfig.TokenLength
        }</span>
        <span class="cov0" title="0">if config.CookieName == "" </span><span class="cov0" title="0">{
                config.CookieName = DefaultCSRFConfig.CookieName
        }</span>
        <span class="cov0" title="0">if config.CookieMaxAge == 0 </span><span class="cov0" title="0">{
                config.CookieMaxAge = DefaultCSRFConfig.CookieMaxAge
        }</span>

        <span class="cov0" title="0">return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(ctx echo.Context) error </span><span class="cov0" title="0">{
                        if config.Skipper(ctx) </span><span class="cov0" title="0">{
                                return next(ctx)
                        }</span>

                        <span class="cov0" title="0">token := ""
                        if tokenCookie, err := ctx.Cookie(config.CookieName); err != nil || tokenCookie.Value == "" </span><span class="cov0" title="0">{
                                token = random.String(config.TokenLength)
                        }</span> else<span class="cov0" title="0"> {
                                token = tokenCookie.Value
                        }</span>

                        <span class="cov0" title="0">switch </span>{
                        case config.SetterTokenInUnsafeMethod(ctx), ctx.Request().Method == http.MethodGet, ctx.Request().Method == http.MethodHead, ctx.Request().Method == http.MethodOptions, ctx.Request().Method == http.MethodTrace:<span class="cov0" title="0"></span>
                        default:<span class="cov0" title="0">
                                // Validate token only for requests which are not defined as 'safe' by RFC7231
                                clientToken := ctx.Request().Header.Get(echo.HeaderXCSRFToken)
                                if clientToken != token </span><span class="cov0" title="0">{
                                        return httpErrDescr.NewHTTPError(ctx, http.StatusForbidden, httpErrDescr.INVALID_CSRF)
                                }</span>
                        }

                        <span class="cov0" title="0">cookie := &amp;http.Cookie{
                                Expires:  time.Now().Add(time.Duration(config.CookieMaxAge) * time.Second),
                                Secure:   true,
                                HttpOnly: true,
                                Name:     config.CookieName,
                                Value:    token,
                        }
                        if config.CookiePath != "" </span><span class="cov0" title="0">{
                                cookie.Path = config.CookiePath
                        }</span>
                        <span class="cov0" title="0">if config.CookieDomain != "" </span><span class="cov0" title="0">{
                                cookie.Domain = config.CookieDomain
                        }</span>
                        <span class="cov0" title="0">ctx.SetCookie(cookie)

                        ctx.Set(csrfCtxKey, token)

                        ctx.Response().Header().Add(echo.HeaderVary, echo.HeaderCookie)
                        return next(ctx)</span>
                }
        }
}

func GetCSRFTokenromCtx(ctx echo.Context) string <span class="cov0" title="0">{
        token, ok := ctx.Get(csrfCtxKey).(string)
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return token</span>
}

func CsrfSetHeader(next echo.HandlerFunc) echo.HandlerFunc <span class="cov0" title="0">{
        return func(ctx echo.Context) error </span><span class="cov0" title="0">{
                k, ok := ctx.Get("csrf").(string)
                if ok &amp;&amp; ctx.Request().Method == http.MethodGet || ctx.Request().Method == http.MethodHead || ctx.Request().Method == http.MethodOptions || ctx.Request().Method == http.MethodTrace </span><span class="cov0" title="0">{
                        ctx.Response().Header().Add("X-CSRF-Token", k)
                }</span>
                <span class="cov0" title="0">return next(ctx)</span>
        }
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package middleware

import (
        "net/http"

        "github.com/pkg/errors"

        "github.com/labstack/echo/v4"
)

func (mw *CommonMiddlewareChain) ErrorHandler(err error, ctx echo.Context) <span class="cov0" title="0">{
        requestId := GetRequestIdFromCtx(ctx)

        if mw.Logger != nil &amp;&amp; requestId &gt; 0 </span><span class="cov0" title="0">{
                mw.Logger.Error(requestId, err.Error())
        }</span>

        <span class="cov0" title="0">switch err := errors.Cause(err).(type) </span>{
        case *echo.HTTPError:<span class="cov0" title="0">
                ctx.JSON(err.Code, struct {
                        Error string `json:"error"`
                }{Error: err.Message.(string)})</span>
        default:<span class="cov0" title="0">
                ctx.JSON(http.StatusInternalServerError, struct {
                        Error string `json:"error"`
                }{Error: "internal server error"})</span>
        }
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package middleware

import (
        auth "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/authManager"
        log "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/logger"
)

type CommonMiddlewareChain struct {
        Logger      *log.ServLogger
        AuthManager auth.AuthManager
}

func NewCommonMiddlewareChain(logger *log.ServLogger, authManager auth.AuthManager) CommonMiddlewareChain <span class="cov0" title="0">{
        return CommonMiddlewareChain{Logger: logger,
                AuthManager: authManager,
        }
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package middleware

import (
        "fmt"
        "net/http"
        "time"

        "github.com/labstack/echo/v4"
)

func (mw *CommonMiddlewareChain) PanicMiddleware(next echo.HandlerFunc) echo.HandlerFunc <span class="cov0" title="0">{
        return func(ctx echo.Context) error </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if err := recover(); err != nil </span><span class="cov0" title="0">{
                                requestId := GetRequestIdFromCtx(ctx)
                                mw.Logger.Error(requestId, "panic recovered: "+fmt.Sprint(err))
                                mw.Logger.Access(requestId, ctx.Request().Method, ctx.Request().RemoteAddr, ctx.Request().URL.Path, time.Duration(0))
                                ctx.JSON(http.StatusInternalServerError, struct {
                                        Error string `json:"error"`
                                }{Error: "internal server error"})
                        }</span>
                }()
                <span class="cov0" title="0">return next(ctx)</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package middleware

import (
        "github.com/labstack/echo/v4"
)

const RequestIdCtxKey = "reqId"

var requestId uint64 = 1

func nextRecId() uint64 <span class="cov0" title="0">{
        requestId++
        return requestId
}</span>

func (mw *CommonMiddlewareChain) RequestIdMiddleware(next echo.HandlerFunc) echo.HandlerFunc <span class="cov0" title="0">{
        return func(ctx echo.Context) error </span><span class="cov0" title="0">{
                currReqId := nextRecId()
                ctx.Set(RequestIdCtxKey, currReqId)
                return next(ctx)
        }</span>
}

func GetRequestIdFromCtx(ctx echo.Context) uint64 <span class="cov8" title="1">{
        reqId, ok := ctx.Get(RequestIdCtxKey).(uint64)
        if !ok </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov0" title="0">return reqId</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package restaurantsHandler

import (
        "encoding/json"
        "math"
        "net/http"
        "strconv"

        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/delivery/http/httpErrDescr"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/delivery/http/middleware"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/dishes"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/models"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/servErrors"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/staticManager"
        "github.com/labstack/echo/v4"
)

type DishesHandler struct {
        Ucase         dishes.Ucase
        StaticManager staticManager.FileManager
}

func NewDishesHandler(ucase dishes.Ucase, staticManager staticManager.FileManager) *DishesHandler <span class="cov8" title="1">{
        return &amp;DishesHandler{
                Ucase:         ucase,
                StaticManager: staticManager,
        }
}</span>

// GetDishesByRestaurants Get dishes by restaurant godoc
// @Summary      List dishes by restaurant
// @Description  get dishes by restaurant
// @Tags         Restaurants
// @Accept       json
// @Produce      json
// @Success      200  {object}   models.RestaurantsDishesJsonForKirill
// @Router       /restaurant/:slug [get]
func (h DishesHandler) GetDishesByRestaurants(ctx echo.Context) error <span class="cov8" title="1">{
        logger := middleware.GetLoggerFromCtx(ctx)
        requestId := middleware.GetRequestIdFromCtx(ctx)

        slug := ctx.Param("slug")
        if slug == "" </span><span class="cov8" title="1">{
                return httpErrDescr.NewHTTPError(ctx, http.StatusBadRequest, httpErrDescr.INVALID_DATA)
        }</span>

        <span class="cov8" title="1">restaurantDishes, err := h.Ucase.GetRestaurantDishes(models.GetRestaurantDishesUcaseReq{Slug: slug})

        if err != nil </span><span class="cov8" title="1">{
                cause := servErrors.ErrorAs(err)
                if cause != nil &amp;&amp; cause.Code == servErrors.NO_SUCH_ENTITY_IN_DB </span><span class="cov0" title="0">{
                        return httpErrDescr.NewHTTPError(ctx, http.StatusForbidden, httpErrDescr.NO_SUCH_RESTAURANT)
                }</span>
                <span class="cov8" title="1">logger.Error(requestId, err.Error())
                return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)</span>
        }

        <span class="cov8" title="1">if restaurantDishes == nil </span><span class="cov0" title="0">{
                logger.Error(requestId, "from user-ucase-get-user returned userData==nil and err==nil, unknown error")
                return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)
        }</span>

        <span class="cov8" title="1">rating := 0.0
        if restaurantDishes.ReviewCount != 0 </span><span class="cov8" title="1">{
                rating = math.Round(float64(restaurantDishes.AggRating)*10/float64(restaurantDishes.ReviewCount)) / 10
        }</span>
        <span class="cov8" title="1">resp := &amp;models.GetRestaurantDishesResp{
                Id:             restaurantDishes.Id,
                Name:           restaurantDishes.Name,
                ImagePath:      h.StaticManager.GetRestaurantUrl(restaurantDishes.ImagePath),
                Slug:           restaurantDishes.Slug,
                MinPrice:       restaurantDishes.MinPrice,
                Rating:         rating,
                ReviewCount:    restaurantDishes.ReviewCount,
                TimeToDelivery: strconv.Itoa(restaurantDishes.DownMinutsToDelivery) + "-" + strconv.Itoa(restaurantDishes.UpMinutsToDelivery),
                Dishes:         make([]models.DishResp, len(restaurantDishes.Dishes)),
        }

        for i, dish := range restaurantDishes.Dishes </span><span class="cov8" title="1">{
                resp.Dishes[i] = models.DishResp{
                        Id:           dish.Id,
                        RestaurantId: dish.RestaurantId,
                        Name:         dish.Name,
                        Description:  dish.Description,
                        ImagePath:    h.StaticManager.GetDishesUrl(dish.ImagePath),
                        Calories:     dish.Calories,
                        Price:        dish.Price,
                        Weight:       dish.Weight,
                }
        }</span>

        <span class="cov8" title="1">result, _ := json.Marshal(resp)
        ctx.Response().Header().Add(echo.HeaderContentLength, strconv.Itoa(len(result)))
        return ctx.JSONBlob(http.StatusOK, result)</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package mock

import (
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/models"
        "github.com/stretchr/testify/mock"
)

type DishesRepo struct {
        mock.Mock
}

func (r *DishesRepo) GetRestaurantBySlug(req models.GetRestaurantBySlugRepoReq) (*models.RestaurantRepo, error) <span class="cov8" title="1">{
        if req.Slug == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return &amp;models.RestaurantRepo{
                Id:                   1,
                Name:                 "Name",
                ImagePath:            "ImagePath",
                Slug:                 "Slug",
                MinPrice:             1,
                AggRating:            9,
                ReviewCount:          2,
                UpMinutsToDelivery:   3,
                DownMinutsToDelivery: 2}, nil</span>
}

func (r *DishesRepo) GetRestaurantDishes(req models.GetRestaurantDishesRepoReq) (*models.GetRestaurantDishesRepoResp, error) <span class="cov8" title="1">{
        if req.Id == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return &amp;models.GetRestaurantDishesRepoResp{Dishes: []models.DishRepo{{Id: 1, Name: "Name", Description: "Description", Price: 10, Weight: 100, Calories: 200, RestaurantId: 1, ImagePath: "DishImagePath"}}}, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package mock

import (
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/models"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/servErrors"
        "github.com/stretchr/testify/mock"
)

type DishesUcase struct {
        mock.Mock
}

func (u *DishesUcase) GetRestaurantDishes(req models.GetRestaurantDishesUcaseReq) (*models.GetRestaurantDishesUcaseResp, error) <span class="cov8" title="1">{
        if req.Slug == "" </span><span class="cov0" title="0">{
                return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, "")
        }</span>

        <span class="cov8" title="1">return &amp;models.GetRestaurantDishesUcaseResp{
                Id:                   1,
                Name:                 "Name",
                ImagePath:            "ImagePath",
                Slug:                 "Slug",
                MinPrice:             1,
                AggRating:            9,
                ReviewCount:          2,
                UpMinutsToDelivery:   3,
                DownMinutsToDelivery: 2,
                Dishes:               []models.DishUcase{{Id: 1, Name: "Name", Description: "Description", Price: 10, Weight: 100, Calories: 200, RestaurantId: 1, ImagePath: "DishImagePath"}},
        }, nil</span>
}

type DishesUcaseErr struct {
        mock.Mock
}

func (a *DishesUcaseErr) GetRestaurantDishes(req models.GetRestaurantDishesUcaseReq) (*models.GetRestaurantDishesUcaseResp, error) <span class="cov8" title="1">{
        return nil, servErrors.NewError(servErrors.UNKNOWN_ERROR, "")
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package repository

import (
        "database/sql"

        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/models"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/servErrors"
        "github.com/jmoiron/sqlx"
)

type DishesRepo struct {
        DB *sqlx.DB
}

func NewDishesRepo(db *sqlx.DB) *DishesRepo <span class="cov0" title="0">{
        return &amp;DishesRepo{DB: db}
}</span>

func (r *DishesRepo) GetRestaurantBySlug(req models.GetRestaurantBySlugRepoReq) (*models.RestaurantRepo, error) <span class="cov8" title="1">{
        restaurant := &amp;models.RestaurantRepo{}
        err := r.DB.Get(restaurant, "SELECT id, name,  image_path, slug, min_price, agg_rating, review_count, up_time_to_delivery, down_time_to_delivery FROM restaurants WHERE slug = $1", req.Slug)
        switch err </span>{
        case nil:<span class="cov8" title="1">
                return restaurant, nil</span>
        case sql.ErrNoRows:<span class="cov8" title="1">
                return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, err.Error())</span>
        default:<span class="cov8" title="1">
                return nil, servErrors.NewError(servErrors.DB_ERROR, err.Error())</span>
        }
}

func (r *DishesRepo) GetRestaurantDishes(req models.GetRestaurantDishesRepoReq) (*models.GetRestaurantDishesRepoResp, error) <span class="cov8" title="1">{
        dishes := make([]*models.DishRepo, 0)
        err := r.DB.Select(&amp;dishes, "SELECT id, restaurant_id, name, description, image_path, calories, price, weight FROM dishes WHERE restaurant_id = $1", req.Id)
        switch err </span>{
        case nil:<span class="cov8" title="1">
                resp := &amp;models.GetRestaurantDishesRepoResp{Dishes: make([]models.DishRepo, len(dishes))}
                for i, dish := range dishes </span><span class="cov8" title="1">{
                        resp.Dishes[i] = *dish
                }</span>
                <span class="cov8" title="1">return resp, nil</span>
        case sql.ErrNoRows:<span class="cov8" title="1">
                return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, err.Error())</span>
        default:<span class="cov8" title="1">
                return nil, servErrors.NewError(servErrors.DB_ERROR, err.Error())</span>
        }
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package ucase

import (
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/dishes"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/models"
        "github.com/pkg/errors"
)

type DishesUcase struct {
        Repo dishes.Repository
}

func NewDishesUcase(restaurantsRepo dishes.Repository) *DishesUcase <span class="cov8" title="1">{
        return &amp;DishesUcase{
                Repo: restaurantsRepo,
        }
}</span>

func (u *DishesUcase) GetRestaurantDishes(req models.GetRestaurantDishesUcaseReq) (*models.GetRestaurantDishesUcaseResp, error) <span class="cov8" title="1">{
        restaurant, err := u.Repo.GetRestaurantBySlug(models.GetRestaurantBySlugRepoReq(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "error getting restaurant")
        }</span>
        <span class="cov8" title="1">dishes, err := u.Repo.GetRestaurantDishes(models.GetRestaurantDishesRepoReq{Id: restaurant.Id})
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "error getting restaurant dishes")
        }</span>

        <span class="cov8" title="1">Resp := &amp;models.GetRestaurantDishesUcaseResp{
                Id:                   restaurant.Id,
                Name:                 restaurant.Name,
                ImagePath:            restaurant.ImagePath,
                Slug:                 restaurant.Slug,
                MinPrice:             restaurant.MinPrice,
                AggRating:            restaurant.AggRating,
                ReviewCount:          restaurant.ReviewCount,
                UpMinutsToDelivery:   restaurant.UpMinutsToDelivery,
                DownMinutsToDelivery: restaurant.DownMinutsToDelivery,
                Dishes:               make([]models.DishUcase, len(dishes.Dishes)),
        }

        for i, dish := range dishes.Dishes </span><span class="cov8" title="1">{
                Resp.Dishes[i] = models.DishUcase(dish)
        }</span>

        <span class="cov8" title="1">return Resp, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package metrics

import "github.com/prometheus/client_golang/prometheus"

type Metric struct {
        TotalHits prometheus.Counter
        Hits      *prometheus.CounterVec
        Errors    *prometheus.CounterVec
        Durations *prometheus.HistogramVec
}

func CreateNewMetric(name string) (*Metric, error) <span class="cov0" title="0">{
        var m Metric

        m.TotalHits = prometheus.NewCounter(prometheus.CounterOpts{
                Name: name + "_total",
        })

        if err := prometheus.Register(m.TotalHits); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">m.Hits = prometheus.NewCounterVec(prometheus.CounterOpts{
                Name: name + "_hits",
        }, []string{"status", "method", "path"},
        )
        if err := prometheus.Register(m.Hits); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">m.Errors = prometheus.NewCounterVec(prometheus.CounterOpts{
                Name: name + "_errors",
        }, []string{"status", "method", "path"},
        )
        if err := prometheus.Register(m.Errors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">m.Durations = prometheus.NewHistogramVec(prometheus.HistogramOpts{
                Name: name + "_durations",
        }, []string{"status", "method", "path"},
        )
        if err := prometheus.Register(m.Durations); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;m, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package metrics

import (
        "github.com/labstack/echo/v4"
        "net/http"
        "strconv"
        "time"
)

func (m *Metric) CollectMetrics(next echo.HandlerFunc) echo.HandlerFunc <span class="cov0" title="0">{
        return func(context echo.Context) error </span><span class="cov0" title="0">{
                timeStart := time.Now()

                defer func() </span><span class="cov0" title="0">{
                        m.TotalHits.Inc()
                        if context.Response().Status != http.StatusOK </span><span class="cov0" title="0">{
                                m.Errors.WithLabelValues(strconv.Itoa(context.Response().Status), context.Request().Method, context.Request().RequestURI).Inc()
                        }</span> else<span class="cov0" title="0"> {
                                m.Hits.WithLabelValues(strconv.Itoa(context.Response().Status), context.Request().Method, context.Request().RequestURI).Inc()
                        }</span>

                        <span class="cov0" title="0">m.Durations.WithLabelValues(strconv.Itoa(context.Response().Status), context.Request().Method, context.Request().RequestURI).Observe(time.Since(timeStart).Seconds())</span>
                }()

                <span class="cov0" title="0">return next(context)</span>
        }
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package orderHandler

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"

        "github.com/asaskevich/govalidator"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/delivery/http/httpErrDescr"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/delivery/http/middleware"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/models"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/order"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/servErrors"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/staticManager"
        "github.com/labstack/echo/v4"
)

type OrderHandler struct {
        Ucase         order.Ucase
        StaticManager staticManager.FileManager
}

func NewOrderHandler(ucase order.Ucase, staticManager staticManager.FileManager) *OrderHandler <span class="cov0" title="0">{
        return &amp;OrderHandler{
                Ucase:         ucase,
                StaticManager: staticManager,
        }
}</span>

func (h OrderHandler) CreateOrder(ctx echo.Context) error <span class="cov0" title="0">{
        user := middleware.GetUserFromCtx(ctx)
        if user == nil </span><span class="cov0" title="0">{
                return httpErrDescr.NewHTTPError(ctx, http.StatusUnauthorized, httpErrDescr.AUTH_REQUIRED)
        }</span>
        <span class="cov0" title="0">logger := middleware.GetLoggerFromCtx(ctx)
        requestId := middleware.GetRequestIdFromCtx(ctx)

        var orderReq models.OrderReq
        if err := ctx.Bind(&amp;orderReq); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
                fmt.Println(ctx.Request().Body)
                return httpErrDescr.NewHTTPError(ctx, http.StatusBadRequest, httpErrDescr.BAD_REQUEST_BODY)
        }</span>
        <span class="cov0" title="0">if _, err := govalidator.ValidateStruct(orderReq); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                return httpErrDescr.NewHTTPError(ctx, http.StatusBadRequest, httpErrDescr.INVALID_DATA)
        }</span>

        <span class="cov0" title="0">newOrderId, err := h.Ucase.CreateOrder(&amp;models.OrderUcaseReq{UserId: user.Id, Address: orderReq.Address, Cart: orderReq.Cart, Comment: orderReq.Comment})
        if err != nil </span><span class="cov0" title="0">{
                cause := servErrors.ErrorAs(err)
                if cause == nil </span><span class="cov0" title="0">{
                        logger.Error(requestId, err.Error())
                        //return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)
                        return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)
                }</span>
                <span class="cov0" title="0">switch cause.Code </span>{
                case servErrors.DB_INSERT:<span class="cov0" title="0">
                        return httpErrDescr.NewHTTPError(ctx, http.StatusConflict, httpErrDescr.CREATING_ORDER)</span>
                default:<span class="cov0" title="0">
                        logger.Error(requestId, err.Error())
                        return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)</span>
                }
        }
        <span class="cov0" title="0">return ctx.JSON(http.StatusOK, models.OrderResp{OrderId: newOrderId.OrderId})</span>
}

func (h OrderHandler) GetUserOrders(ctx echo.Context) error <span class="cov0" title="0">{
        user := middleware.GetUserFromCtx(ctx)
        if user == nil </span><span class="cov0" title="0">{
                return httpErrDescr.NewHTTPError(ctx, http.StatusUnauthorized, httpErrDescr.AUTH_REQUIRED)
        }</span>
        <span class="cov0" title="0">logger := middleware.GetLoggerFromCtx(ctx)
        requestId := middleware.GetRequestIdFromCtx(ctx)

        orders, err := h.Ucase.GetUserOrders(&amp;models.GetUserOrdersUcaseReq{UserId: int64(user.Id)})
        if err != nil </span><span class="cov0" title="0">{
                cause := servErrors.ErrorAs(err)
                if cause != nil &amp;&amp; cause.Code == servErrors.NO_SUCH_ENTITY_IN_DB </span><span class="cov0" title="0">{
                        //return httpErrDescr.NewHTTPError(ctx, http.StatusForbidden, httpErrDescr.NO_SUCH_USER)
                        return httpErrDescr.NewHTTPError(ctx, http.StatusForbidden, httpErrDescr.NO_SUCH_USER)
                }</span>
                <span class="cov0" title="0">logger.Error(requestId, err.Error())
                return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)</span>
        }

        <span class="cov0" title="0">resp := models.GetUserOrdersResp{Orders: make([]models.ShortOrder, len(orders.Orders))}
        for i, order := range orders.Orders </span><span class="cov0" title="0">{
                resp.Orders[i] = models.ShortOrder(order)
        }</span>
        <span class="cov0" title="0">result, _ := json.Marshal(resp)
        ctx.Response().Header().Add(echo.HeaderContentLength, strconv.Itoa(len(result)))
        return ctx.JSONBlob(http.StatusOK, result)</span>
}

func (h OrderHandler) GetUserOrderStatuses(ctx echo.Context) error <span class="cov0" title="0">{
        user := middleware.GetUserFromCtx(ctx)
        if user == nil </span><span class="cov0" title="0">{
                return httpErrDescr.NewHTTPError(ctx, http.StatusUnauthorized, httpErrDescr.AUTH_REQUIRED)
        }</span>
        <span class="cov0" title="0">logger := middleware.GetLoggerFromCtx(ctx)
        requestId := middleware.GetRequestIdFromCtx(ctx)

        orderStatuses, err := h.Ucase.GetUserOrderStatuses(&amp;models.GetUserOrderStatusesUcaseReq{UserId: int64(user.Id)})
        if err != nil </span><span class="cov0" title="0">{
                cause := servErrors.ErrorAs(err)
                if cause != nil &amp;&amp; cause.Code == servErrors.NO_SUCH_ENTITY_IN_DB </span><span class="cov0" title="0">{
                        //return httpErrDescr.NewHTTPError(ctx, http.StatusForbidden, httpErrDescr.NO_SUCH_USER)
                        return httpErrDescr.NewHTTPError(ctx, http.StatusForbidden, httpErrDescr.NO_SUCH_USER)
                }</span>
                <span class="cov0" title="0">logger.Error(requestId, err.Error())
                return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)</span>
        }

        <span class="cov0" title="0">resp := models.GetUserOrderStatusesResp{OrderStatuses: make([]models.OrderStatus, len(orderStatuses.OrderStatuses))}
        for i, order := range orderStatuses.OrderStatuses </span><span class="cov0" title="0">{
                resp.OrderStatuses[i] = models.OrderStatus(order)
        }</span>
        <span class="cov0" title="0">fmt.Println(resp)
        result, _ := json.Marshal(resp)
        ctx.Response().Header().Add(echo.HeaderContentLength, strconv.Itoa(len(result)))
        return ctx.JSONBlob(http.StatusOK, result)</span>
}

func (h OrderHandler) GetUserOrder(ctx echo.Context) error <span class="cov0" title="0">{
        user := middleware.GetUserFromCtx(ctx)
        if user == nil </span><span class="cov0" title="0">{
                return httpErrDescr.NewHTTPError(ctx, http.StatusUnauthorized, httpErrDescr.AUTH_REQUIRED)
        }</span>
        <span class="cov0" title="0">logger := middleware.GetLoggerFromCtx(ctx)
        requestId := middleware.GetRequestIdFromCtx(ctx)

        orderId, err := strconv.Atoi(ctx.Param("orderId"))
        if err != nil </span><span class="cov0" title="0">{
                return httpErrDescr.NewHTTPError(ctx, http.StatusBadRequest, httpErrDescr.BAD_ORDER_ID)
        }</span>

        <span class="cov0" title="0">orderUcaseData, err := h.Ucase.GetUserOrder(&amp;models.GetUserOrderUcaseReq{UserId: int64(user.Id), OrderId: int64(orderId)})
        if err != nil </span><span class="cov0" title="0">{
                cause := servErrors.ErrorAs(err)
                if cause != nil &amp;&amp; cause.Code == servErrors.THIS_ORDER_DOESNOT_BELONG_USER </span><span class="cov0" title="0">{
                        //return httpErrDescr.NewHTTPError(ctx, http.StatusForbidden, httpErrDescr.THIS_ORDER_DOESNOT_BELONG_USER)
                        return httpErrDescr.NewHTTPError(ctx, http.StatusForbidden, httpErrDescr.THIS_ORDER_DOESNOT_BELONG_USER)
                }</span>

                <span class="cov0" title="0">if cause != nil &amp;&amp; cause.Code == servErrors.NO_SUCH_ENTITY_IN_DB </span><span class="cov0" title="0">{
                        return httpErrDescr.NewHTTPError(ctx, http.StatusForbidden, httpErrDescr.NO_SUCH_USER)
                }</span>
                <span class="cov0" title="0">logger.Error(requestId, err.Error())
                return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)</span>
        }
        <span class="cov0" title="0">fmt.Println(orderUcaseData.Status)
        resp := models.GetUserOrderResp{OrderId: orderUcaseData.OrderId, Address: orderUcaseData.Address, Date: orderUcaseData.Date, RestaurantName: orderUcaseData.RestaurantName, RestaurantSlug: orderUcaseData.RestaurantSlug, Status: orderUcaseData.Status, TotalPrice: orderUcaseData.TotalPrice, Cart: make([]models.OrderPositionResp, len(orderUcaseData.Cart))}
        for i, order := range orderUcaseData.Cart </span><span class="cov0" title="0">{
                order.ImagePath = h.StaticManager.GetDishesUrl(order.ImagePath)
                resp.Cart[i] = models.OrderPositionResp(order)
        }</span>
        <span class="cov0" title="0">fmt.Println(resp)
        result, _ := json.Marshal(resp)
        ctx.Response().Header().Add(echo.HeaderContentLength, strconv.Itoa(len(result)))
        return ctx.JSONBlob(http.StatusOK, result)</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package ucase

import (
        "context"

        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/models"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/servErrors"
        orderProto "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/order/proto"
        "google.golang.org/grpc/status"
)

type OrderUcase struct {
        OrderCli orderProto.OrderServiceClient
}

func NewUcase(orderCli orderProto.OrderServiceClient) *OrderUcase <span class="cov0" title="0">{
        return &amp;OrderUcase{
                OrderCli: orderCli,
        }
}</span>

func (u *OrderUcase) CreateOrder(order *models.OrderUcaseReq) (*models.OrderUcaseResp, error) <span class="cov0" title="0">{
        cart := make([]*orderProto.OrderPositionReq, len(order.Cart))
        for i, position := range order.Cart </span><span class="cov0" title="0">{
                cart[i] = &amp;orderProto.OrderPositionReq{Id: position.Id, Count: position.Count}
        }</span>
        <span class="cov0" title="0">orderResp, err := u.OrderCli.CreateOrder(context.Background(), &amp;orderProto.CreateOrderReq{UserId: int64(order.UserId), Address: order.Address, Comment: order.Comment, Cart: cart})
        if err != nil </span><span class="cov0" title="0">{
                return nil, servErrors.NewError(int(status.Code(err)), err.Error())
        }</span>
        <span class="cov0" title="0">return &amp;models.OrderUcaseResp{OrderId: orderResp.OrderId}, err</span>
}

func (u *OrderUcase) GetUserOrders(order *models.GetUserOrdersUcaseReq) (*models.GetUserOrdersUcaseResp, error) <span class="cov0" title="0">{
        orders, err := u.OrderCli.GetUserOrders(context.Background(), &amp;orderProto.GetUserOrdersReq{UserId: int64(order.UserId)})

        if err != nil </span><span class="cov0" title="0">{
                return nil, servErrors.NewError(int(status.Code(err)), err.Error())
        }</span>

        <span class="cov0" title="0">ordersResp := make([]models.ShortOrderUcase, len(orders.Orders))
        for i, order := range orders.Orders </span><span class="cov0" title="0">{
                ordersResp[i] = models.ShortOrderUcase{OrderId: order.OrderId, Date: order.Date, Status: order.Status, RestaurantName: order.RestaurantName, TotalPrice: order.TotalPrice}
        }</span>
        <span class="cov0" title="0">return &amp;models.GetUserOrdersUcaseResp{Orders: ordersResp}, err</span>
}

func (u *OrderUcase) GetUserOrderStatuses(order *models.GetUserOrderStatusesUcaseReq) (*models.GetUserOrderStatusesUcaseResp, error) <span class="cov0" title="0">{
        orders, err := u.OrderCli.GetUserOrderStatuses(context.Background(), &amp;orderProto.GetUserOrderStatusesReq{UserId: int64(order.UserId)})

        if err != nil </span><span class="cov0" title="0">{
                return nil, servErrors.NewError(int(status.Code(err)), err.Error())
        }</span>

        <span class="cov0" title="0">ordersResp := make([]models.OrderStatusUcase, len(orders.OrderStatuses))
        for i, order := range orders.OrderStatuses </span><span class="cov0" title="0">{
                ordersResp[i] = models.OrderStatusUcase{OrderId: order.OrderId, Status: order.Status}
        }</span>
        <span class="cov0" title="0">return &amp;models.GetUserOrderStatusesUcaseResp{OrderStatuses: ordersResp}, err</span>
}

func (u *OrderUcase) GetUserOrder(req *models.GetUserOrderUcaseReq) (*models.GetUserOrderUcaseResp, error) <span class="cov0" title="0">{
        order, err := u.OrderCli.GetUserOrder(context.Background(), &amp;orderProto.GetUserOrderReq{UserId: int64(req.UserId), OrderId: req.OrderId})

        if err != nil </span><span class="cov0" title="0">{
                return nil, servErrors.NewError(int(status.Code(err)), err.Error())
        }</span>

        <span class="cov0" title="0">resp := models.GetUserOrderUcaseResp{OrderId: order.OrderId, Address: order.Address, Date: order.Date, RestaurantName: order.RestaurantName, RestaurantSlug: order.RestaurantSlug, TotalPrice: order.TotalPrice, Status: order.Status, Cart: make([]models.OrderPositionUcaseResp, len(order.Cart))}
        for i, poz := range order.Cart </span><span class="cov0" title="0">{
                resp.Cart[i] = models.OrderPositionUcaseResp{Name: poz.Name, Description: poz.Description, ImagePath: poz.ImagePath, Calories: poz.Calories, Count: poz.Count, Price: poz.Price, Weigth: poz.Weigth}
        }</span>
        <span class="cov0" title="0">return &amp;resp, err</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package restaurantsHandler

import (
        "encoding/json"
        "math"
        "net/http"
        "strconv"

        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/delivery/http/httpErrDescr"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/delivery/http/middleware"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/models"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/restaurants"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/servErrors"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/staticManager"
        "github.com/labstack/echo/v4"
)

type RestaurantsHandler struct {
        Ucase         restaurants.Ucase
        StaticManager staticManager.FileManager
}

func NewRestaurantsHandler(ucase restaurants.Ucase, staticManager staticManager.FileManager) *RestaurantsHandler <span class="cov8" title="1">{
        return &amp;RestaurantsHandler{
                Ucase:         ucase,
                StaticManager: staticManager,
        }
}</span>

// GetAllRestaurants Restaurants godoc
// @Summary      List restaurants
// @Description  Get restaurants
// @Tags         Restaurants
// @Accept       json
// @Produce      json
// @Success      200  {object} []models.RestaurantJsonForKirill
// @Router       /restaurants [get]
func (h RestaurantsHandler) GetAllRestaurants(ctx echo.Context) error <span class="cov8" title="1">{
        logger := middleware.GetLoggerFromCtx(ctx)
        requestId := middleware.GetRequestIdFromCtx(ctx)

        ucaseRest, err := h.Ucase.GetAllRestaurants()

        if err != nil </span><span class="cov8" title="1">{
                cause := servErrors.ErrorAs(err)
                if cause != nil &amp;&amp; cause.Code == servErrors.NO_SUCH_ENTITY_IN_DB </span><span class="cov0" title="0">{
                        return httpErrDescr.NewHTTPError(ctx, http.StatusForbidden, httpErrDescr.NO_SUCH_RESTAURANTS)
                }</span>
                <span class="cov8" title="1">logger.Error(requestId, err.Error())
                return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)</span>
        }

        <span class="cov8" title="1">if ucaseRest == nil </span><span class="cov0" title="0">{
                logger.Error(requestId, "from restaurants-handler-getall returned restaurantsDataDelivery==nil and err==nil, unknown error")
                return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)
        }</span>

        <span class="cov8" title="1">restaurantsResp := &amp;models.AllRestaurantsResp{Restaurants: make([]models.RestaurantResp, len(ucaseRest.Restaurants))}
        for i, rest := range ucaseRest.Restaurants </span><span class="cov8" title="1">{
                rating := 0.0
                if rest.ReviewCount != 0 </span><span class="cov8" title="1">{
                        rating = math.Round(float64(rest.AggRating)*10/float64(rest.ReviewCount)) / 10
                }</span>
                <span class="cov8" title="1">restaurantsResp.Restaurants[i] = models.RestaurantResp{
                        Id:             rest.Id,
                        Name:           rest.Name,
                        ImagePath:      h.StaticManager.GetRestaurantUrl(rest.ImagePath),
                        Slug:           rest.Slug,
                        MinPrice:       rest.MinPrice,
                        Rating:         rating,
                        TimeToDelivery: strconv.Itoa(rest.DownMinutsToDelivery) + "-" + strconv.Itoa(rest.UpMinutsToDelivery),
                }</span>
        }

        <span class="cov8" title="1">result, _ := json.Marshal(restaurantsResp.Restaurants)
        ctx.Response().Header().Add(echo.HeaderContentLength, strconv.Itoa(len(result)))
        return ctx.JSONBlob(http.StatusOK, result)</span>
}

func (h RestaurantsHandler) GetRestaurantsByCategory(ctx echo.Context, category string) error <span class="cov8" title="1">{
        logger := middleware.GetLoggerFromCtx(ctx)
        requestId := middleware.GetRequestIdFromCtx(ctx)

        ucaseResp, err := h.Ucase.GetRestaurantsByCategory(models.GetRestaurantByCategoryUcaseReq{Name: category})

        if err != nil </span><span class="cov8" title="1">{
                cause := servErrors.ErrorAs(err)
                if cause != nil &amp;&amp; cause.Code == servErrors.NO_SUCH_ENTITY_IN_DB </span><span class="cov0" title="0">{
                        //return httpErrDescr.NewHTTPError(ctx, http.StatusForbidden, httpErrDescr.NO_SUCH_RESTAURANTS)
                        return httpErrDescr.NewHTTPError(ctx, http.StatusForbidden, httpErrDescr.NO_SUCH_RESTAURANTS)
                }</span>
                <span class="cov8" title="1">logger.Error(requestId, err.Error())
                return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)</span>
        }

        <span class="cov8" title="1">if ucaseResp == nil </span><span class="cov0" title="0">{
                logger.Error(requestId, "from restaurants-handler-getall returned restaurantsDataDelivery==nil and err==nil, unknown error")
                return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)
        }</span>

        <span class="cov8" title="1">restaurantsResp := &amp;models.AllRestaurantsResp{Restaurants: make([]models.RestaurantResp, len(ucaseResp.Restaurants))}
        for i, rest := range ucaseResp.Restaurants </span><span class="cov8" title="1">{
                rating := 0.0
                if rest.ReviewCount != 0 </span><span class="cov8" title="1">{
                        rating = math.Round(float64(rest.AggRating)*10/float64(rest.ReviewCount)) / 10
                }</span>
                <span class="cov8" title="1">restaurantsResp.Restaurants[i] = models.RestaurantResp{
                        Id:             rest.Id,
                        Name:           rest.Name,
                        ImagePath:      h.StaticManager.GetRestaurantUrl(rest.ImagePath),
                        Slug:           rest.Slug,
                        MinPrice:       rest.MinPrice,
                        Rating:         rating,
                        TimeToDelivery: strconv.Itoa(rest.DownMinutsToDelivery) + "-" + strconv.Itoa(rest.UpMinutsToDelivery),
                }</span>
        }

        <span class="cov8" title="1">result, _ := json.Marshal(restaurantsResp.Restaurants)
        ctx.Response().Header().Add(echo.HeaderContentLength, strconv.Itoa(len(result)))
        return ctx.JSONBlob(http.StatusOK, result)</span>
}

func (h RestaurantsHandler) GetRestaurantsBySeachQuery(ctx echo.Context, query string) error <span class="cov8" title="1">{
        logger := middleware.GetLoggerFromCtx(ctx)
        requestId := middleware.GetRequestIdFromCtx(ctx)

        ucaseResp, err := h.Ucase.GetRestaurantBySearchQuery(models.GetRestaurantBySearchQueryUcaseReq{Query: query})

        if err != nil </span><span class="cov8" title="1">{
                cause := servErrors.ErrorAs(err)
                if cause != nil &amp;&amp; cause.Code == servErrors.NO_SUCH_ENTITY_IN_DB </span><span class="cov0" title="0">{
                        return httpErrDescr.NewHTTPError(ctx, http.StatusForbidden, httpErrDescr.NO_SUCH_RESTAURANTS)
                }</span>
                <span class="cov8" title="1">logger.Error(requestId, err.Error())
                return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)</span>
        }

        <span class="cov8" title="1">if ucaseResp == nil </span><span class="cov0" title="0">{
                logger.Error(requestId, "from restaurants-handler-getall returned restaurantsDataDelivery==nil and err==nil, unknown error")
                return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)
        }</span>

        <span class="cov8" title="1">restaurantsResp := &amp;models.AllRestaurantsResp{Restaurants: make([]models.RestaurantResp, len(ucaseResp.Restaurants))}
        for i, rest := range ucaseResp.Restaurants </span><span class="cov8" title="1">{
                rating := 0.0
                if rest.ReviewCount != 0 </span><span class="cov8" title="1">{
                        rating = math.Round(float64(rest.AggRating)*10/float64(rest.ReviewCount)) / 10
                }</span>
                <span class="cov8" title="1">restaurantsResp.Restaurants[i] = models.RestaurantResp{
                        Id:             rest.Id,
                        Name:           rest.Name,
                        ImagePath:      h.StaticManager.GetRestaurantUrl(rest.ImagePath),
                        Slug:           rest.Slug,
                        MinPrice:       rest.MinPrice,
                        Rating:         rating,
                        TimeToDelivery: strconv.Itoa(rest.DownMinutsToDelivery) + "-" + strconv.Itoa(rest.UpMinutsToDelivery),
                }</span>
        }

        <span class="cov8" title="1">result, _ := json.Marshal(restaurantsResp.Restaurants)
        ctx.Response().Header().Add(echo.HeaderContentLength, strconv.Itoa(len(result)))
        return ctx.JSONBlob(http.StatusOK, result)</span>
}

func (h RestaurantsHandler) GetAllRestaurantsMain(ctx echo.Context) error <span class="cov8" title="1">{
        searhQuery := ctx.QueryParam("q")
        category := ctx.QueryParam("category")

        if category != "" </span><span class="cov8" title="1">{
                return h.GetRestaurantsByCategory(ctx, category)
        }</span>

        <span class="cov8" title="1">if searhQuery != "" </span><span class="cov8" title="1">{
                return h.GetRestaurantsBySeachQuery(ctx, searhQuery)
        }</span>

        <span class="cov8" title="1">return h.GetAllRestaurants(ctx)</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package mock

import (
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/models"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/servErrors"
        "github.com/stretchr/testify/mock"
)

type RestaurantsUcase struct {
        mock.Mock
}

func (a *RestaurantsUcase) GetAllRestaurants() (*models.RestaurantsUcase, error) <span class="cov8" title="1">{
        return &amp;models.RestaurantsUcase{Restaurants: []models.RestaurantUcase{{
                Id:                   1,
                Name:                 "Name",
                ImagePath:            "ImagePath",
                Slug:                 "slug",
                MinPrice:             1,
                AggRating:            9,
                ReviewCount:          2,
                UpMinutsToDelivery:   3,
                DownMinutsToDelivery: 2}}}, nil
}</span>

func (a *RestaurantsUcase) GetRestaurantsByCategory(category models.GetRestaurantByCategoryUcaseReq) (*models.RestaurantsUcase, error) <span class="cov8" title="1">{
        return &amp;models.RestaurantsUcase{Restaurants: []models.RestaurantUcase{{
                Id:                   1,
                Name:                 "Name",
                ImagePath:            "ImagePath",
                Slug:                 "slug",
                MinPrice:             1,
                AggRating:            9,
                ReviewCount:          2,
                UpMinutsToDelivery:   3,
                DownMinutsToDelivery: 2}}}, nil
}</span>

func (a *RestaurantsUcase) GetRestaurantBySearchQuery(query models.GetRestaurantBySearchQueryUcaseReq) (*models.RestaurantsUcase, error) <span class="cov8" title="1">{
        return &amp;models.RestaurantsUcase{Restaurants: []models.RestaurantUcase{{
                Id:                   1,
                Name:                 "Name",
                ImagePath:            "ImagePath",
                Slug:                 "slug",
                MinPrice:             1,
                AggRating:            9,
                ReviewCount:          2,
                UpMinutsToDelivery:   3,
                DownMinutsToDelivery: 2}}}, nil
}</span>

type RestaurantsUcaseErr struct {
        mock.Mock
}

func (a *RestaurantsUcaseErr) GetAllRestaurants() (*models.RestaurantsUcase, error) <span class="cov8" title="1">{
        return nil, servErrors.NewError(servErrors.DB_ERROR, "")
}</span>

func (a *RestaurantsUcaseErr) GetRestaurantsByCategory(category models.GetRestaurantByCategoryUcaseReq) (*models.RestaurantsUcase, error) <span class="cov8" title="1">{
        return nil, servErrors.NewError(servErrors.DB_ERROR, "")
}</span>

func (a *RestaurantsUcaseErr) GetRestaurantBySearchQuery(query models.GetRestaurantBySearchQueryUcaseReq) (*models.RestaurantsUcase, error) <span class="cov8" title="1">{
        return nil, servErrors.NewError(servErrors.DB_ERROR, "")
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package repository

import (
        "fmt"

        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/models"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/servErrors"
        "github.com/jmoiron/sqlx"
)

type RestaurantsRepo struct {
        DB *sqlx.DB
}

func NewRestaurantsRepo(db *sqlx.DB) *RestaurantsRepo <span class="cov0" title="0">{
        return &amp;RestaurantsRepo{DB: db}
}</span>

func (r *RestaurantsRepo) GetRestaurants() (*models.RestaurantsRepo, error) <span class="cov0" title="0">{
        restaurants := make([]*models.RestaurantRepo, 0)
        err := r.DB.Select(&amp;restaurants, "SELECT id, name,  image_path, slug, min_price, agg_rating, review_count, up_time_to_delivery, down_time_to_delivery FROM restaurants")
        switch err </span>{
        case nil:<span class="cov0" title="0">
                resp := models.RestaurantsRepo{Restaurants: make([]models.RestaurantRepo, len(restaurants))}
                for i, restaurant := range restaurants </span><span class="cov0" title="0">{
                        resp.Restaurants[i] = *restaurant
                }</span>
                <span class="cov0" title="0">return &amp;resp, nil</span>
        default:<span class="cov0" title="0">
                return nil, servErrors.NewError(servErrors.DB_ERROR, err.Error())</span>
        }
}

func (r *RestaurantsRepo) GetRestaurantsByCategory(category models.GetRestaurantByCategoryRepoReq) (*models.RestaurantsRepo, error) <span class="cov0" title="0">{
        restaurants := make([]*models.RestaurantRepo, 0)
        err := r.DB.Select(&amp;restaurants, `SELECT r.id id, r.name, r.image_path image_path, r.slug slug, r.min_price min_price, r.agg_rating agg_rating, r.review_count review_count, up_time_to_delivery, down_time_to_delivery FROM restaurants r JOIN categori_restaurant cr ON r.id=cr.restaurant_id JOIN categories c ON cr.categori_id=c.id WHERE c.name=$1`, category.Name)
        switch err </span>{
        case nil:<span class="cov0" title="0">
                resp := models.RestaurantsRepo{Restaurants: make([]models.RestaurantRepo, len(restaurants))}
                for i, restaurant := range restaurants </span><span class="cov0" title="0">{
                        resp.Restaurants[i] = *restaurant
                }</span>
                <span class="cov0" title="0">return &amp;resp, nil</span>
        default:<span class="cov0" title="0">
                return nil, servErrors.NewError(servErrors.DB_ERROR, err.Error())</span>
        }
}

func (r *RestaurantsRepo) GetRestaurantsBySeachQuery(query models.GetRestaurantBySearchQueryRepoReq) (*models.RestaurantsRepo, error) <span class="cov0" title="0">{
        restaurants := make([]*models.RestaurantRepo, 0)
        err := r.DB.Select(&amp;restaurants, `SELECT r.id id, r.name, r.image_path image_path, r.slug slug, r.min_price min_price, r.agg_rating agg_rating, r.review_count review_count, up_time_to_delivery, down_time_to_delivery FROM restaurants r JOIN categori_restaurant cr ON r.id=cr.restaurant_id JOIN categories c ON cr.categori_id=c.id WHERE c.name ILIKE $1`, query.Query+"%")
        fmt.Println(`SELECT r.id id, r.name, r.image_path image_path, r.slug slug, r.min_price min_price, r.agg_rating agg_rating, r.review_count review_count, up_time_to_delivery, down_time_to_delivery FROM restaurants r JOIN categori_restaurant cr ON r.id=cr.restaurant_id JOIN categories c ON cr.categori_id=c.id WHERE c.name ILIKE `, query.Query+"%")
        fmt.Println(restaurants)
        fmt.Println(err)
        if len(restaurants) == 0 </span><span class="cov0" title="0">{
                fmt.Println(`SELECT id id, name, image_path image_path, slug slug, min_price min_price, agg_rating agg_rating, review_count review_count, up_time_to_delivery, down_time_to_delivery FROM restaurants WHERE name ILIKE `, query.Query, "%")
                err = r.DB.Select(&amp;restaurants, `SELECT id id, name, image_path image_path, slug slug, min_price min_price, agg_rating agg_rating, review_count review_count, up_time_to_delivery, down_time_to_delivery FROM restaurants WHERE name ILIKE $1`, query.Query+"%")
        }</span>
        <span class="cov0" title="0">switch err </span>{
        case nil:<span class="cov0" title="0">
                resp := models.RestaurantsRepo{Restaurants: make([]models.RestaurantRepo, len(restaurants))}
                for i, restaurant := range restaurants </span><span class="cov0" title="0">{
                        resp.Restaurants[i] = *restaurant
                }</span>
                <span class="cov0" title="0">return &amp;resp, nil</span>
        default:<span class="cov0" title="0">
                fmt.Println(restaurants, err)
                return nil, servErrors.NewError(servErrors.DB_ERROR, err.Error())</span>
        }
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package ucase

import (
        "strings"

        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/models"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/restaurants"
        "github.com/pkg/errors"
)

type RestaurantsUcase struct {
        RestaurantsRepo restaurants.Repository
}

func NewRestaurantsUcase(restaurantsRepo restaurants.Repository) *RestaurantsUcase <span class="cov0" title="0">{
        return &amp;RestaurantsUcase{
                RestaurantsRepo: restaurantsRepo,
        }
}</span>

func (u *RestaurantsUcase) GetAllRestaurants() (*models.RestaurantsUcase, error) <span class="cov0" title="0">{
        restaurantsRepoResp, err := u.RestaurantsRepo.GetRestaurants()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "error getting restaurants")
        }</span>

        <span class="cov0" title="0">restaurantsResp := &amp;models.RestaurantsUcase{Restaurants: make([]models.RestaurantUcase, len(restaurantsRepoResp.Restaurants))}

        for i, rest := range restaurantsRepoResp.Restaurants </span><span class="cov0" title="0">{
                restaurantsResp.Restaurants[i] = models.RestaurantUcase(rest)
        }</span>

        <span class="cov0" title="0">return restaurantsResp, nil</span>
}

func (u *RestaurantsUcase) GetRestaurantsByCategory(category models.GetRestaurantByCategoryUcaseReq) (*models.RestaurantsUcase, error) <span class="cov0" title="0">{
        restaurantsRepoResp, err := u.RestaurantsRepo.GetRestaurantsByCategory(models.GetRestaurantByCategoryRepoReq(category))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "error getting restaurants")
        }</span>

        <span class="cov0" title="0">restaurantsResp := &amp;models.RestaurantsUcase{Restaurants: make([]models.RestaurantUcase, len(restaurantsRepoResp.Restaurants))}

        for i, rest := range restaurantsRepoResp.Restaurants </span><span class="cov0" title="0">{
                restaurantsResp.Restaurants[i] = models.RestaurantUcase(rest)
        }</span>

        <span class="cov0" title="0">return restaurantsResp, nil</span>
}

func (u *RestaurantsUcase) GetRestaurantBySearchQuery(query models.GetRestaurantBySearchQueryUcaseReq) (*models.RestaurantsUcase, error) <span class="cov0" title="0">{
        query.Query = strings.Trim(query.Query, " \n\t")
        restaurantsRepoResp, err := u.RestaurantsRepo.GetRestaurantsBySeachQuery(models.GetRestaurantBySearchQueryRepoReq(query))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "error getting restaurants")
        }</span>

        <span class="cov0" title="0">restaurantsResp := &amp;models.RestaurantsUcase{Restaurants: make([]models.RestaurantUcase, len(restaurantsRepoResp.Restaurants))}

        for i, rest := range restaurantsRepoResp.Restaurants </span><span class="cov0" title="0">{
                restaurantsResp.Restaurants[i] = models.RestaurantUcase(rest)
        }</span>

        <span class="cov0" title="0">return restaurantsResp, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package authManager

import (
        "time"

        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/models"
)

type TokenPayload struct {
        Id  models.UserId `valid:"userId, required"`
        Exp time.Time     `valid:"expired, required"`
}

const (
        idTitle      = "id"
        expiresTitle = "expired"
)

func NewTokenPayload(id models.UserId) *TokenPayload <span class="cov0" title="0">{
        return &amp;TokenPayload{
                Id: id,
        }
}</span>

type AuthManager interface {
        CreateToken(payload *TokenPayload) (string, error)
        ParseToken(token string) (*TokenPayload, error)
        GetEpiryTime() time.Duration
}

func TokenPayloadToMap(payload TokenPayload) map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                idTitle:      payload.Id,
                expiresTitle: payload.Exp,
        }
}</span>

func MapToTokenPayload(payloadMap map[string]interface{}) *TokenPayload <span class="cov0" title="0">{
        expStr, ok := payloadMap[expiresTitle].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">exp, _ := time.Parse(time.RFC3339, expStr)
        return &amp;TokenPayload{
                Id:  models.UserId(payloadMap[idTitle].(float64)),
                Exp: exp,
        }</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package jwtManager

import (
        "time"

        conf "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/config"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/authManager"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/servErrors"
        jwt "github.com/golang-jwt/jwt"
        "github.com/pkg/errors"
)

type JwtManager struct {
        key         []byte
        method      jwt.SigningMethod
        expDuration time.Duration
}

func NewJwtManager(cfg conf.AuthManagerConfig) *JwtManager <span class="cov0" title="0">{
        methodObj := jwt.GetSigningMethod(cfg.Method)
        if methodObj == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;JwtManager{
                key:         []byte(cfg.Key),
                method:      methodObj,
                expDuration: cfg.ExpiryTime.Duration,
        }</span>
}

func (manager *JwtManager) GetEpiryTime() time.Duration <span class="cov0" title="0">{
        return manager.expDuration
}</span>

func (manager *JwtManager) CreateToken(payload *authManager.TokenPayload) (string, error) <span class="cov0" title="0">{
        payload.Exp = time.Now().Add(manager.expDuration)
        token := jwt.NewWithClaims(manager.method, jwt.MapClaims(authManager.TokenPayloadToMap(*payload)))
        if token == nil </span><span class="cov0" title="0">{
                return "", servErrors.NewError(servErrors.CREATE_TOKEN, "error creating jwt-token")
        }</span>
        <span class="cov0" title="0">tokenSigned, err := token.SignedString(manager.key)
        if err != nil </span><span class="cov0" title="0">{
                return "", servErrors.NewError(servErrors.CREATE_TOKEN, "error signing jwt-token: "+err.Error())
        }</span>
        <span class="cov0" title="0">return tokenSigned, nil</span>
}

func (manager *JwtManager) ParseToken(token string) (*authManager.TokenPayload, error) <span class="cov0" title="0">{
        jwtToken, err := jwt.Parse(token, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return manager.key, nil</span>
        })

        <span class="cov0" title="0">if jwtToken == nil || err != nil </span><span class="cov0" title="0">{
                return nil, servErrors.NewError(servErrors.PARSE_TOKEN, "error parsing jwt-token: "+err.Error())
        }</span>

        <span class="cov0" title="0">claims, ok := jwtToken.Claims.(jwt.MapClaims)
        if !ok || !jwtToken.Valid </span><span class="cov0" title="0">{
                return nil, servErrors.NewError(servErrors.WRONG_TOKEN_CLAIMS, "jwt-token not valid")
        }</span>
        <span class="cov0" title="0">return authManager.MapToTokenPayload(claims), nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package cacher

type Cacher interface {
        Set(item *Item) error
        Get(key string) (*Item, error)
        Delete(key string) error
}

type Item struct {
        Key   string
        Value []byte
        // Flags are server-opaque flags whose semantics are entirely
        // up to the app.
        // Flags uint32

        // Expiration is the cache expiration time, in seconds: either a relative
        // time from now (up to 1 month), or an absolute Unix epoch time.
        // Zero means the Item has no expiration time.
        Expiration int32
        // contains filtered or unexported fields
}

func NewItem(key string, value []byte, expiration int32) *Item <span class="cov0" title="0">{
        return &amp;Item{
                Key:        key,
                Value:      value,
                Expiration: expiration,
        }
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package memcacher

import (
        "strconv"

        "github.com/bradfitz/gomemcache/memcache"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/config"
        cacher "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/cacher"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/servErrors"
)

type Memcacher struct {
        client *memcache.Client
}

func NewMemcacher(cfg *config.CachConfig) (*Memcacher, error) <span class="cov0" title="0">{
        client := memcache.New(cfg.Host + ":" + strconv.Itoa(cfg.Port))
        if err := client.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Memcacher{
                client: client,
        }, nil</span>
}

func (c *Memcacher) Set(item *cacher.Item) error <span class="cov0" title="0">{
        err := c.client.Set(&amp;memcache.Item{
                Key:        item.Key,
                Value:      item.Value,
                Expiration: item.Expiration,
        })
        if err != nil </span><span class="cov0" title="0">{
                return servErrors.NewError(servErrors.CACH_ERROR, err.Error())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c *Memcacher) Get(key string) (*cacher.Item, error) <span class="cov0" title="0">{
        item, err := c.client.Get(key)
        if err == memcache.ErrCacheMiss </span><span class="cov0" title="0">{
                return nil, servErrors.NewError(servErrors.CACH_MISS_CODE, err.Error())
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, servErrors.NewError(servErrors.CACH_ERROR, err.Error())
        }</span>
        <span class="cov0" title="0">return cacher.NewItem(item.Key, item.Value, item.Expiration), nil</span>
}

func (c *Memcacher) Delete(key string) error <span class="cov0" title="0">{
        err := c.client.Delete(key)
        if err == memcache.ErrCacheMiss </span><span class="cov0" title="0">{
                return servErrors.NewError(servErrors.CACH_MISS_CODE, err.Error())
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return servErrors.NewError(servErrors.CACH_ERROR, err.Error())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// func (c *Memcacher) Swap(item *cacher.Item) error {
//         return c.client.CompareAndSwap(&amp;memcache.Item{
//                 Key:        item.Key,
//                 Value:      item.Value,
//                 Expiration: item.Expiration,
//         })
// }

// func (c *Memcacher) SetOrReplace(item *cacher.Item) error {
//         _, err := c.client.Get(item.Key)
//         if err != nil &amp;&amp; err != memcache.ErrCacheMiss {
//                 return errors.Wrap(err, "memcache get item error")
//         }

//         if err == nil {
//                 return errors.Wrap(c.client.CompareAndSwap(&amp;memcache.Item{
//                         Key:        item.Key,
//                         Value:      item.Value,
//                         Expiration: item.Expiration,
//                 }), "memcache set item error")
//         }

//         return errors.Wrap(c.client.Set(&amp;memcache.Item{
//                 Key:        item.Key,
//                 Value:      item.Value,
//                 Expiration: item.Expiration,
//         }), "memcache set item error")

// }
</pre>
		
		<pre class="file" id="file42" style="display: none">package logger

import (
        "time"
)

type Logger interface {
        // Error(msg string, reqId uint64, errorMsg string)
        Debugw(msg string, keysAndValues ...interface{})
        Errorw(msg string, keysAndValues ...interface{})
        Fatalw(msg string, keysAndValues ...interface{})
        Infow(msg string, keysAndValues ...interface{})
        Panicw(msg string, keysAndValues ...interface{})
        Warnw(msg string, keysAndValues ...interface{})
        Sync() error
}

type ServLogger struct {
        Logger Logger
}

func NewServLogger(logger Logger) *ServLogger <span class="cov0" title="0">{
        return &amp;ServLogger{
                Logger: logger,
        }
}</span>

const (
        AccessMsg          = "access"
        ReqIdTitle         = "request_id"
        MethodTitle        = "method"
        RemoteAddrTitle    = "remote_addr"
        UrlTitle           = "url"
        ProcesingTimeTitle = "processing_time"
        ErrorMsgTitle      = "error_msg"
)

func (l ServLogger) Access(requestId uint64, method, remoteAddr, url string, procesingTime time.Duration) <span class="cov0" title="0">{
        l.Logger.Infow(
                AccessMsg,
                ReqIdTitle, requestId,
                MethodTitle, method,
                RemoteAddrTitle, remoteAddr,
                UrlTitle, url,
                ProcesingTimeTitle, procesingTime,
        )
}</span>

func (l ServLogger) Error(reqId uint64, errorMsg string) <span class="cov8" title="1">{
        l.Logger.Infow(
                "error",
                ReqIdTitle, reqId,
                ErrorMsgTitle, errorMsg,
        )
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package mock

import (
        "github.com/stretchr/testify/mock"
)

type Logger struct {
        mock.Mock
}

func (Logger) Debugw(msg string, keysAndValues ...interface{}) {<span class="cov0" title="0">}</span>
func (Logger) Errorw(msg string, keysAndValues ...interface{}) {<span class="cov0" title="0">}</span>
func (Logger) Fatalw(msg string, keysAndValues ...interface{}) {<span class="cov0" title="0">}</span>
func (Logger) Infow(msg string, keysAndValues ...interface{})  {<span class="cov8" title="1">}</span>
func (Logger) Panicw(msg string, keysAndValues ...interface{}) {<span class="cov0" title="0">}</span>
func (Logger) Warnw(msg string, keysAndValues ...interface{})  {<span class="cov0" title="0">}</span>
func (Logger) Sync() error                                     <span class="cov0" title="0">{ return nil }</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package zaplogger

import (
        conf "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/config"
        "github.com/pkg/errors"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

func NewZapLogger(cfg *conf.LogConfig) (*zap.SugaredLogger, error) <span class="cov0" title="0">{
        level, err := zap.ParseAtomicLevel(cfg.Level)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("unknown logging level")
        }</span>
        <span class="cov0" title="0">zapCfg := zap.Config{
                Level:            level,
                Encoding:         cfg.Encoding,
                OutputPaths:      cfg.OutputPaths,
                ErrorOutputPaths: cfg.ErrorOutputPaths,

                EncoderConfig: zapcore.EncoderConfig{
                        MessageKey:     cfg.MessageKey,
                        LevelKey:       cfg.LevelKey,
                        TimeKey:        cfg.TimeKey,
                        FunctionKey:    cfg.FunctionKey,
                        StacktraceKey:  cfg.StacktraceKey,
                        NameKey:        cfg.NameKey,
                        EncodeDuration: zapcore.StringDurationEncoder,
                        EncodeLevel:    zapcore.LowercaseLevelEncoder,
                        EncodeTime:     zapcore.ISO8601TimeEncoder,
                },
        }
        loggerUnsugared, err := zap.Config(zapCfg).Build()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "creating ZapLogger failed")
        }</span>

        <span class="cov0" title="0">return loggerUnsugared.Sugar(), nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package flashcall

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net/http"
        "time"

        conf "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/config"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/servErrors"
)

type Flashcaller struct {
        apiKey string
        email  string
}

// TODO: отправлять по хттпС
const (
        flasgcallUrlFmt = "http://%s:%s@gate.smsaero.ru/v2/flashcall/send?phone=%s&amp;code=%s"
        contentTypeJson = "application/json"
)

// {
//         "success": true,
//         "data": {
//                 "id": 1,
//                 "status": 0,
//                 "code": "1234",
//                 "phone": "79990000000",
//                 "cost": "0.59",
//                 "timeCreate": 1646926190,
//                 "timeUpdate": 1646926190
//         },
//         "message": null
// }

type flashcallResponse struct {
        Success bool   `json:"success"`
        Message string `json:"message"`
}

func NewFlashcaller(cfg *conf.NotificatorConfig) *Flashcaller <span class="cov0" title="0">{
        return &amp;Flashcaller{
                apiKey: cfg.ApiKey,
                email:  cfg.Email,
        }
}</span>

func (f Flashcaller) SendCode(phone string, code string) error <span class="cov0" title="0">{

        client := http.Client{Timeout: 3 * time.Second}

        response, err := client.Get(fmt.Sprintf(flasgcallUrlFmt, f.email, f.apiKey, phone, code))
        if err != nil </span><span class="cov0" title="0">{
                return servErrors.NewError(servErrors.FLASHCALL_RESPONSE_ERR, "error getting response from flashcall server: "+err.Error())
        }</span>

        <span class="cov0" title="0">bodyBuf, err := ioutil.ReadAll(response.Body)
        response.Body.Close()

        if err != nil </span><span class="cov0" title="0">{
                return servErrors.NewError(servErrors.FLASHCALL_RESPONSE_ERR, "error reading response body from flashcall server: "+err.Error())
        }</span>
        <span class="cov0" title="0">var respBody flashcallResponse
        if err := json.Unmarshal(bodyBuf, &amp;respBody); err != nil </span><span class="cov0" title="0">{
                return servErrors.NewError(servErrors.FLASHCALL_RESPONSE_ERR, "error unmarshaling response from flashcall server: "+err.Error())
        }</span>

        <span class="cov0" title="0">if !respBody.Success </span><span class="cov0" title="0">{
                return servErrors.NewError(servErrors.FLASHCALL_RESPONSE_ERR, "flashcall server failed to sent request to queue: "+respBody.Message)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package postgresqlx

import (
        "fmt"

        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/config"
        _ "github.com/jackc/pgx/stdlib"
        "github.com/jmoiron/sqlx"
)

func NewPostgresqlX(cfg *config.DatabaseConfig) (*sqlx.DB, error) <span class="cov0" title="0">{
        dsn := fmt.Sprintf("user=%s dbname=%s password=%s host=%s port=%d", cfg.User, cfg.DbName, cfg.Password, cfg.Host, cfg.Port)
        db, err := sqlx.Connect("pgx", dsn)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">db.SetMaxOpenConns(cfg.ConnectionMax)
        return db, nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package servErrors

import (
        "fmt"

        "github.com/pkg/errors"
)

// ошибки, которые нужно залогировать
const (
        // -iota - 1
        CACH_ERROR = -iota - 1
)

// ошибки, которые не нужно логировать
const (
        OK = iota
        CACH_MISS_CODE
        FLASHCALL_RESPONSE_ERR

        WRONG_AUTH_CODE
        NO_SUCH_RESTAURANT
        NO_SUCH_USER
        SENDING_AUTH_CODE
        CREATE_TOKEN
        PARSE_TOKEN
        WRONG_TOKEN_CLAIMS
        // невалидные данные от пользователя
        NO_SUCH_ENTITY_IN_DB
        INVALID_DATA
        DB_ERROR
        DB_INSERT
        DB_UPDATE
        NO_SUCH_CITY
        NO_SUCH_STREET
        CANT_CREATE_AVATAR_NAME
        CANT_SAVE_AVATAR
        DECODE_IMG
        UNKNOWN_STATIC_TYPE
        UNKNOWN_ERROR
        THIS_ORDER_DOESNOT_BELONG_USER
)

const (
        DB_ERROR_DESCR             = "ошибка при работе с базой данных"
        CACH_MISS_DESCR            = "в кэше отсутствует элемент по данному ключу"
        BAD_AUTH_TOKEN_DESCR       = "не валидный токен авторизации"
        NO_SUCH_RESTAURANT_DESCR   = "не существует такого ресторана"
        NO_SUCH_AUTH_DATA_DESCR    = "не найдены данные для авторизации пользователя"
        BAD_REQUEST_BODY_DESCR     = "не правильное тело запроса"
        WRONG_AUTH_CODE_DESCR      = "не верный код для входа"
        NO_SUCH_ENTITY_IN_DB_DESCR = "нет такой сущности в базе данных"
        NO_SUCH_USER_DESCR         = "не существует такого пользователя"
        // невалидные данные от пользователя
        DB_INSERT_DESCR                      = "неуспешная вставка в базу данных"
        NO_SUCH_CITY_DESCR                   = "не существует такого города"
        NO_SUCH_STREET_DESCR                 = "не существует такой улицы"
        CANT_CREATE_AVATAR_NAME_DESCR        = "не получается сгенерировать имя аватарки"
        CANT_SAVE_AVATAR_DESCR               = "не получается сохранить аватарку"
        UNKNOWN_STATIC_TYPE_DESCR            = "неизвестный тип статики, невозможно определить расположение"
        THIS_ORDER_DOESNOT_BELONG_USER_DESCR = "запрошенный заказ не принадлежит текущему пользователю"
)

var codeDescr = map[int]string{
        NO_SUCH_RESTAURANT:             NO_SUCH_RESTAURANT_DESCR,
        CACH_MISS_CODE:                 CACH_MISS_DESCR,
        NO_SUCH_USER:                   NO_SUCH_USER_DESCR,
        THIS_ORDER_DOESNOT_BELONG_USER: THIS_ORDER_DOESNOT_BELONG_USER_DESCR,
}

type Error struct {
        Description string
        Code        int
}

func (e Error) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("error with code %d description: %s", e.Code, e.Description)
}</span>

func (e Error) Cause() error <span class="cov0" title="0">{
        return e
}</span>

func NewError(eCode int, eDescr string) Error <span class="cov8" title="1">{
        if eDescr == "" </span><span class="cov8" title="1">{
                eDescr = codeDescr[eCode]
        }</span>
        <span class="cov8" title="1">return Error{
                Code:        eCode,
                Description: eDescr,
        }</span>
}

func ErrorAs(e error) *Error <span class="cov8" title="1">{
        var cause Error
        if ok := errors.As(e, &amp;cause); ok </span><span class="cov8" title="1">{
                return &amp;cause
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package localStaticManager

import (
        "image"
        "os"

        "github.com/disintegration/imaging"
)

type LocalFileManager struct {
        staticUrl      string
        staticPath     string
        avatarPath     string
        restaurantPath string
        dishesPath     string
}

func NewLocalFileManager(staticUrl string, staticPath string) *LocalFileManager <span class="cov8" title="1">{
        return &amp;LocalFileManager{
                staticUrl:      staticUrl,
                staticPath:     staticPath,
                avatarPath:     "avatar/",
                restaurantPath: "restaurants/",
                dishesPath:     "dishes/",
        }
}</span>

func (f *LocalFileManager) SafeAvatar(img image.Image, imgName string) error <span class="cov0" title="0">{
        return imaging.Save(img, f.staticPath+f.avatarPath+imgName)
}</span>

func (f *LocalFileManager) RemoveAvatar(avatarName string) error <span class="cov0" title="0">{
        return os.Remove(f.staticPath + f.avatarPath + avatarName)
}</span>

func (f *LocalFileManager) IsNotSuchAvatarExist(avatarName string) bool <span class="cov0" title="0">{
        _, err := os.Stat(f.staticPath + f.avatarPath + avatarName)
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return os.IsNotExist(err)</span>
}

func (f *LocalFileManager) GetAvatarUrl(fileName string) string <span class="cov0" title="0">{
        if fileName == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return f.staticUrl + f.avatarPath + fileName</span>
}

func (f *LocalFileManager) GetAvatarDirPath() string <span class="cov0" title="0">{
        return f.staticPath + f.avatarPath
}</span>

func (f *LocalFileManager) GetRestaurantUrl(fileName string) string <span class="cov8" title="1">{
        return f.staticUrl + f.restaurantPath + fileName
}</span>

func (f *LocalFileManager) GetDishesUrl(fileName string) string <span class="cov8" title="1">{
        return f.staticUrl + f.dishesPath + fileName
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package validator

import (
        "regexp"
        "time"

        "github.com/asaskevich/govalidator"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/models"
)

const (
        phoneRegexp   = `^7[94][0-9]{9}$`
        nameRegexp    = `^[A-ZА-Я]{1}[a-zа-я]{2,25}$`
        addressRegexp = `^[a-zA-Zа-яА-Я0-9 \,\.]{0,256}$` // TODO: составить норм регулярки
        // commentRegexp = `^[a-zA-Zа-яА-Я0-9 \-\/,.]{,512}$` // TODO: составить норм регулярки
)

func init() <span class="cov8" title="1">{
        govalidator.CustomTypeTagMap.Set(
                "name",
                govalidator.CustomTypeValidator(func(i interface{}, o interface{}) bool </span><span class="cov0" title="0">{
                        name, ok := i.(string)
                        if !ok </span><span class="cov0" title="0">{
                                return false
                        }</span>

                        <span class="cov0" title="0">isName, _ := regexp.MatchString(nameRegexp, name)
                        return isName</span>
                }),
        )
        <span class="cov8" title="1">govalidator.CustomTypeTagMap.Set(
                "address",
                govalidator.CustomTypeValidator(func(i interface{}, o interface{}) bool </span><span class="cov8" title="1">{
                        addr, ok := i.(string)
                        if !ok </span><span class="cov0" title="0">{
                                return false
                        }</span>

                        <span class="cov8" title="1">isAddr, _ := regexp.MatchString(addressRegexp, addr)
                        return isAddr</span>
                }),
        )
        <span class="cov8" title="1">govalidator.CustomTypeTagMap.Set(
                "comment",
                govalidator.CustomTypeValidator(func(i interface{}, o interface{}) bool </span><span class="cov0" title="0">{
                        // comment, ok := i.(string)
                        // if !ok {
                        //         return false
                        // }

                        // isComment, _ := regexp.MatchString(addressRegexp, comment)
                        // return isComment

                        return true
                }</span>),
        )
        <span class="cov8" title="1">govalidator.CustomTypeTagMap.Set(
                "phone",
                govalidator.CustomTypeValidator(func(i interface{}, o interface{}) bool </span><span class="cov0" title="0">{
                        phone, ok := i.(string)
                        if !ok </span><span class="cov0" title="0">{
                                return false
                        }</span>

                        <span class="cov0" title="0">isPhone, _ := regexp.MatchString(phoneRegexp, phone)
                        return isPhone</span>
                }),
        )

        <span class="cov8" title="1">govalidator.CustomTypeTagMap.Set(
                "userId",
                govalidator.CustomTypeValidator(func(i interface{}, o interface{}) bool </span><span class="cov0" title="0">{
                        id, ok := i.(models.UserId)
                        if !ok </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov0" title="0">if id &lt;= 0 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov0" title="0">return true</span>
                }),
        )
        <span class="cov8" title="1">govalidator.CustomTypeTagMap.Set(
                "expired",
                govalidator.CustomTypeValidator(func(i interface{}, o interface{}) bool </span><span class="cov0" title="0">{
                        exp, ok := i.(time.Time)
                        if !ok </span><span class="cov0" title="0">{
                                return false
                        }</span>

                        <span class="cov0" title="0">if exp.Before(time.Now()) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov0" title="0">return true</span>
                }),
        )
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package userHandler

import (
        "fmt"
        "net"
        "net/http"
        "time"

        "github.com/asaskevich/govalidator"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/delivery/http/httpErrDescr"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/delivery/http/middleware"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/models"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/authManager"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/servErrors"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/staticManager"
        _ "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/validator"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/user"
        "github.com/labstack/echo/v4"
)

const (
        tokenCookieKey    = "token"
        CSRFCookieName    = "_csrf"
        avatarMaxSize     = 4000000
        updateUserMaxSize = 1000
)

type UserHandler struct {
        Ucase         user.Ucase
        AuthManager   authManager.AuthManager
        StaticManager staticManager.FileManager
}

func NewUserHandler(ucase user.Ucase, authManager authManager.AuthManager, staticManager staticManager.FileManager) *UserHandler <span class="cov0" title="0">{
        return &amp;UserHandler{
                Ucase:         ucase,
                AuthManager:   authManager,
                StaticManager: staticManager,
        }
}</span>

func createTokenCookie(token string, domen string, exp time.Duration) *http.Cookie <span class="cov0" title="0">{
        return &amp;http.Cookie{
                Name:     tokenCookieKey,
                Value:    token,
                HttpOnly: true,
                Expires:  time.Now().Add(exp),
                Domain:   domen,
                Path:     "/",
        }
}</span>

func (h UserHandler) Login(ctx echo.Context) error <span class="cov0" title="0">{
        if middleware.GetUserFromCtx(ctx) != nil </span><span class="cov0" title="0">{
                return httpErrDescr.NewHTTPError(ctx, http.StatusConflict, httpErrDescr.ALREADY_AUTHORIZED)
        }</span>

        <span class="cov0" title="0">logger := middleware.GetLoggerFromCtx(ctx)
        requestId := middleware.GetRequestIdFromCtx(ctx)

        var loginReq models.LoginReq
        if err := ctx.Bind(&amp;loginReq); err != nil </span><span class="cov0" title="0">{
                return httpErrDescr.NewHTTPError(ctx, http.StatusBadRequest, httpErrDescr.BAD_REQUEST_BODY)
        }</span>
        <span class="cov0" title="0">if _, err := govalidator.ValidateStruct(loginReq); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                fmt.Println(loginReq)
                return httpErrDescr.NewHTTPError(ctx, http.StatusBadRequest, httpErrDescr.INVALID_DATA)
        }</span>

        <span class="cov0" title="0">userDataUcase, err := h.Ucase.Login(&amp;models.LoginUcaseReq{Phone: loginReq.Phone, Code: loginReq.Code})
        if err != nil </span><span class="cov0" title="0">{
                cause := servErrors.ErrorAs(err)
                if cause == nil </span><span class="cov0" title="0">{
                        fmt.Println("-----------------cause == nil--------------")
                        logger.Error(requestId, err.Error())
                        return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)
                }</span>
                <span class="cov0" title="0">switch cause.Code </span>{
                case servErrors.WRONG_AUTH_CODE:<span class="cov0" title="0">
                        return httpErrDescr.NewHTTPError(ctx, http.StatusForbidden, httpErrDescr.WRONG_AUTH_CODE)</span>
                case servErrors.CACH_MISS_CODE:<span class="cov0" title="0">
                        return httpErrDescr.NewHTTPError(ctx, http.StatusNotFound, httpErrDescr.NO_SUCH_CODE_INFO)</span>
                case servErrors.NO_SUCH_ENTITY_IN_DB:<span class="cov0" title="0">
                        return httpErrDescr.NewHTTPError(ctx, http.StatusNotFound, httpErrDescr.NO_SUCH_USER)</span>
                default:<span class="cov0" title="0">
                        logger.Error(requestId, err.Error())
                        return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)</span>
                }
        }

        <span class="cov0" title="0">if userDataUcase == nil </span><span class="cov0" title="0">{
                logger.Error(requestId, "from user-ucase-register returned userData==nil and err==nil, unknown error")
                return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)
        }</span>

        <span class="cov0" title="0">token, err := h.AuthManager.CreateToken(authManager.NewTokenPayload(userDataUcase.Id))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(requestId, "error creating token: "+err.Error())
                return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)
        }</span>

        <span class="cov0" title="0">host, _, _ := net.SplitHostPort(ctx.Request().Host)
        tokenCookie := createTokenCookie(token, host, h.AuthManager.GetEpiryTime())

        ctx.SetCookie(tokenCookie)
        csrfToken := middleware.GetCSRFTokenromCtx(ctx)
        if csrfToken != "" </span><span class="cov0" title="0">{
                ctx.Response().Header().Add(echo.HeaderXCSRFToken, csrfToken)
        }</span>
        <span class="cov0" title="0">return ctx.JSON(http.StatusOK, models.UserDataResp{Phone: userDataUcase.Phone, Email: userDataUcase.Email, Name: userDataUcase.Name, Avatar: h.StaticManager.GetAvatarUrl(userDataUcase.Avatar)})</span>
}

func (h UserHandler) Register(ctx echo.Context) error <span class="cov0" title="0">{

        if middleware.GetUserFromCtx(ctx) != nil </span><span class="cov0" title="0">{
                return httpErrDescr.NewHTTPError(ctx, http.StatusConflict, httpErrDescr.ALREADY_AUTHORIZED)
        }</span>

        <span class="cov0" title="0">logger := middleware.GetLoggerFromCtx(ctx)
        requestId := middleware.GetRequestIdFromCtx(ctx)

        var registerReq models.RegisterReq

        if err := ctx.Bind(&amp;registerReq); err != nil </span><span class="cov0" title="0">{
                return httpErrDescr.NewHTTPError(ctx, http.StatusBadRequest, httpErrDescr.BAD_REQUEST_BODY)
        }</span>
        <span class="cov0" title="0">if _, err := govalidator.ValidateStruct(registerReq); err != nil </span><span class="cov0" title="0">{
                return httpErrDescr.NewHTTPError(ctx, http.StatusBadRequest, httpErrDescr.INVALID_DATA)
        }</span>

        <span class="cov0" title="0">userDataUcase, err := h.Ucase.Register(&amp;models.RegisterUcaseReq{Phone: registerReq.Phone, Code: registerReq.Code, Name: registerReq.Name, Email: registerReq.Email})
        if err != nil </span><span class="cov0" title="0">{
                cause := servErrors.ErrorAs(err)
                if cause == nil </span><span class="cov0" title="0">{
                        logger.Error(requestId, err.Error())
                        return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)
                }</span>
                <span class="cov0" title="0">switch cause.Code </span>{
                case servErrors.WRONG_AUTH_CODE:<span class="cov0" title="0">
                        return httpErrDescr.NewHTTPError(ctx, http.StatusForbidden, httpErrDescr.WRONG_AUTH_CODE)</span>
                case servErrors.CACH_MISS_CODE:<span class="cov0" title="0">
                        return httpErrDescr.NewHTTPError(ctx, http.StatusNotFound, httpErrDescr.NO_SUCH_CODE_INFO)</span>
                case servErrors.DB_INSERT:<span class="cov0" title="0">
                        return httpErrDescr.NewHTTPError(ctx, http.StatusConflict, httpErrDescr.SUCH_USER_ALREADY_EXISTS)</span>
                default:<span class="cov0" title="0">
                        logger.Error(requestId, err.Error())
                        return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)</span>
                }
        }
        <span class="cov0" title="0">if userDataUcase == nil </span><span class="cov0" title="0">{
                logger.Error(requestId, "from user-ucase-register returned userData==nil and err==nil, unknown error")
                return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)
        }</span>

        <span class="cov0" title="0">token, err := h.AuthManager.CreateToken(authManager.NewTokenPayload(userDataUcase.Id))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(requestId, "error creating token: "+err.Error())
                return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)
        }</span>

        <span class="cov0" title="0">host, _, _ := net.SplitHostPort(ctx.Request().Host)
        tokenCookie := createTokenCookie(token, host, h.AuthManager.GetEpiryTime())

        ctx.SetCookie(tokenCookie)
        csrfToken := middleware.GetCSRFTokenromCtx(ctx)
        if csrfToken != "" </span><span class="cov0" title="0">{
                ctx.Response().Header().Add(echo.HeaderXCSRFToken, csrfToken)
        }</span>
        <span class="cov0" title="0">return ctx.JSON(http.StatusOK, models.UserDataResp{Phone: userDataUcase.Phone, Email: userDataUcase.Email, Name: userDataUcase.Name, Avatar: h.StaticManager.GetAvatarUrl(userDataUcase.Avatar)})</span>
}

func (h UserHandler) Logout(ctx echo.Context) error <span class="cov0" title="0">{
        if middleware.GetUserFromCtx(ctx) == nil </span><span class="cov0" title="0">{
                return httpErrDescr.NewHTTPError(ctx, http.StatusUnauthorized, httpErrDescr.AUTH_REQUIRED)
        }</span>
        <span class="cov0" title="0">host, _, _ := net.SplitHostPort(ctx.Request().Host)
        resetTokenCookie := createTokenCookie("", host, -time.Hour)

        resetCsrfCookie := &amp;http.Cookie{
                Name:    CSRFCookieName,
                Expires: time.Now().Add(-time.Hour),
                Domain:  host,
                Path:    "/",
        }

        ctx.SetCookie(resetTokenCookie)
        ctx.SetCookie(resetCsrfCookie)
        return ctx.NoContent(http.StatusOK)</span>
}

func (h UserHandler) SendCode(ctx echo.Context) error <span class="cov0" title="0">{
        if middleware.GetUserFromCtx(ctx) != nil </span><span class="cov0" title="0">{
                return httpErrDescr.NewHTTPError(ctx, http.StatusConflict, httpErrDescr.ALREADY_AUTHORIZED)
        }</span>

        <span class="cov0" title="0">logger := middleware.GetLoggerFromCtx(ctx)
        requestId := middleware.GetRequestIdFromCtx(ctx)

        var sendCodeReq models.SendCodeReq
        if err := ctx.Bind(&amp;sendCodeReq); err != nil </span><span class="cov0" title="0">{
                return httpErrDescr.NewHTTPError(ctx, http.StatusBadRequest, httpErrDescr.BAD_REQUEST_BODY)
        }</span>
        <span class="cov0" title="0">if _, err := govalidator.ValidateStruct(sendCodeReq); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err, sendCodeReq)
                return httpErrDescr.NewHTTPError(ctx, http.StatusBadRequest, httpErrDescr.INVALID_DATA)
        }</span>
        <span class="cov0" title="0">isRegistered, err := h.Ucase.SendCode(&amp;models.SendCodeUcaseReq{Phone: sendCodeReq.Phone})
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(requestId, "error sending code: "+err.Error())
                return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)
        }</span>
        <span class="cov0" title="0">return ctx.JSON(http.StatusOK, models.SendCodeResp{IsRegistered: isRegistered.IsRegistered})</span>
}

func (h UserHandler) GetUser(ctx echo.Context) error <span class="cov0" title="0">{
        user := middleware.GetUserFromCtx(ctx)
        if user == nil </span><span class="cov0" title="0">{
                return ctx.JSON(http.StatusOK, ``)
        }</span>

        <span class="cov0" title="0">logger := middleware.GetLoggerFromCtx(ctx)
        requestId := middleware.GetRequestIdFromCtx(ctx)

        userDataUcase, err := h.Ucase.GetUser(user.Id)

        if err != nil </span><span class="cov0" title="0">{
                cause := servErrors.ErrorAs(err)
                if cause != nil &amp;&amp; cause.Code == servErrors.NO_SUCH_ENTITY_IN_DB </span><span class="cov0" title="0">{
                        return httpErrDescr.NewHTTPError(ctx, http.StatusForbidden, httpErrDescr.NO_SUCH_USER)
                }</span>
                <span class="cov0" title="0">logger.Error(requestId, err.Error())
                return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)</span>
        }

        <span class="cov0" title="0">if userDataUcase == nil </span><span class="cov0" title="0">{
                logger.Error(requestId, "from user-ucase-get-user returned userData==nil and err==nil, unknown error")
                return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)
        }</span>

        <span class="cov0" title="0">csrfToken := middleware.GetCSRFTokenromCtx(ctx)
        if csrfToken != "" </span><span class="cov0" title="0">{
                ctx.Response().Header().Add(echo.HeaderXCSRFToken, csrfToken)
        }</span>
        <span class="cov0" title="0">return ctx.JSON(http.StatusOK, models.UserDataResp{Phone: userDataUcase.Phone, Email: userDataUcase.Email, Name: userDataUcase.Name, Avatar: h.StaticManager.GetAvatarUrl(userDataUcase.Avatar)})</span>
}

func (h UserHandler) UpdateUser(ctx echo.Context) error <span class="cov0" title="0">{
        user := middleware.GetUserFromCtx(ctx)
        if user == nil </span><span class="cov0" title="0">{
                return httpErrDescr.NewHTTPError(ctx, http.StatusUnauthorized, httpErrDescr.AUTH_REQUIRED)
        }</span>

        <span class="cov0" title="0">err := ctx.Request().ParseMultipartForm(avatarMaxSize + updateUserMaxSize)
        if err != nil </span><span class="cov0" title="0">{
                return httpErrDescr.NewHTTPError(ctx, http.StatusBadRequest, httpErrDescr.BAD_REQUEST_BODY)
        }</span>
        <span class="cov0" title="0">logger := middleware.GetLoggerFromCtx(ctx)
        requestId := middleware.GetRequestIdFromCtx(ctx)

        updateReq := models.UpdateUserReq{
                Name:  ctx.Request().FormValue("name"),
                Email: ctx.Request().FormValue("email"),
        }

        fmt.Println(updateReq.Email)
        fmt.Println(updateReq.Name)

        if _, err := govalidator.ValidateStruct(updateReq); err != nil || (updateReq.Email == "" &amp;&amp; updateReq.Name == "") </span><span class="cov0" title="0">{
                fmt.Println(err)
                return httpErrDescr.NewHTTPError(ctx, http.StatusBadRequest, httpErrDescr.INVALID_DATA)
        }</span>

        <span class="cov0" title="0">avatarImage, _, _ := ctx.Request().FormFile("avatar")
        if avatarImage != nil </span><span class="cov0" title="0">{
                defer avatarImage.Close()
        }</span>

        <span class="cov0" title="0">userDataUcase, err := h.Ucase.UpdateUser(&amp;models.UpdateUserUcase{Id: user.Id, Email: updateReq.Email, Name: updateReq.Name, AvatarImg: avatarImage})

        if err != nil </span><span class="cov0" title="0">{
                cause := servErrors.ErrorAs(err)
                if cause == nil </span><span class="cov0" title="0">{
                        logger.Error(requestId, err.Error())
                        return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)
                }</span>
                <span class="cov0" title="0">switch cause.Code </span>{
                case servErrors.DB_UPDATE:<span class="cov0" title="0">
                        return httpErrDescr.NewHTTPError(ctx, http.StatusConflict, httpErrDescr.SUCH_USER_ALREADY_EXISTS)</span>
                case servErrors.DECODE_IMG:<span class="cov0" title="0">
                        return httpErrDescr.NewHTTPError(ctx, http.StatusBadRequest, httpErrDescr.BAD_IMAGE)</span>
                }
                <span class="cov0" title="0">logger.Error(requestId, err.Error())
                return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)</span>
        }

        <span class="cov0" title="0">if userDataUcase == nil </span><span class="cov0" title="0">{
                logger.Error(requestId, "from user-ucase-get-user returned userData==nil and err==nil, unknown error")
                return httpErrDescr.NewHTTPError(ctx, http.StatusInternalServerError, httpErrDescr.SERVER_ERROR)
        }</span>

        <span class="cov0" title="0">csrfToken := middleware.GetCSRFTokenromCtx(ctx)
        if csrfToken != "" </span><span class="cov0" title="0">{
                ctx.Response().Header().Add(echo.HeaderXCSRFToken, csrfToken)
        }</span>

        <span class="cov0" title="0">return ctx.JSON(http.StatusOK, models.UserDataResp{Phone: userDataUcase.Phone, Email: userDataUcase.Email, Name: userDataUcase.Name, Avatar: h.StaticManager.GetAvatarUrl(userDataUcase.Avatar)})</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package repository

import (
        "database/sql"
        "fmt"

        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/models"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/servErrors"
        "github.com/jmoiron/sqlx"
)

type UserRepo struct {
        DB *sqlx.DB
}

func NewUserRepo(db *sqlx.DB) *UserRepo <span class="cov0" title="0">{
        return &amp;UserRepo{DB: db}
}</span>

func (r *UserRepo) GetUserByPhone(phone string) (*models.UserDataRepo, error) <span class="cov0" title="0">{
        user := &amp;models.UserDataRepo{}
        err := r.DB.Get(user, `SELECT id, phone, email, name, avatar FROM users WHERE phone = $1`, phone)
        fmt.Println(err)
        fmt.Println(user)
        switch err </span>{
        case nil:<span class="cov0" title="0">
                return user, nil</span>
        case sql.ErrNoRows:<span class="cov0" title="0">
                return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, err.Error())</span>
        default:<span class="cov0" title="0">
                return nil, servErrors.NewError(servErrors.DB_ERROR, err.Error())</span>
        }
}

func (r *UserRepo) GetUserById(id models.UserId) (*models.UserDataRepo, error) <span class="cov0" title="0">{
        user := &amp;models.UserDataRepo{}
        err := r.DB.Get(user, `SELECT id, phone, email, name, avatar FROM users WHERE id = $1`, id)

        switch err </span>{
        case nil:<span class="cov0" title="0">
                return user, nil</span>
        case sql.ErrNoRows:<span class="cov0" title="0">
                return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, err.Error())</span>
        default:<span class="cov0" title="0">
                return nil, servErrors.NewError(servErrors.DB_ERROR, err.Error())</span>
        }
}

func (r *UserRepo) UpdateUser(updUser *models.UpdateUserStorage) (*models.UserDataRepo, error) <span class="cov0" title="0">{
        var err error
        user := &amp;models.UserDataRepo{}

        switch </span>{
        case updUser.Email != "" &amp;&amp; updUser.Name != "" &amp;&amp; updUser.Avatar != "":<span class="cov0" title="0">
                err = r.DB.Get(user, `UPDATE users SET name=$1, email=$2, avatar=$3 WHERE id=$4 RETURNING id, name, email, phone, avatar`, updUser.Name, updUser.Email, updUser.Avatar, updUser.Id)</span>
        case updUser.Email != "" &amp;&amp; updUser.Name == "" &amp;&amp; updUser.Avatar == "":<span class="cov0" title="0">
                err = r.DB.Get(user, `UPDATE users SET email=$1 WHERE id=$2 RETURNING id, name, email, phone, avatar`, updUser.Email, updUser.Id)</span>
        case updUser.Email == "" &amp;&amp; updUser.Name != "" &amp;&amp; updUser.Avatar == "":<span class="cov0" title="0">
                err = r.DB.Get(user, `UPDATE users SET name=$1 WHERE id=$2 RETURNING id, name, email, phone, avatar`, updUser.Name, updUser.Id)</span>
        case updUser.Email == "" &amp;&amp; updUser.Name == "" &amp;&amp; updUser.Avatar != "":<span class="cov0" title="0">
                err = r.DB.Get(user, `UPDATE users SET avatar=$1 WHERE id=$2 RETURNING id, name, email, phone, avatar`, updUser.Avatar, updUser.Id)</span>
        case updUser.Email != "" &amp;&amp; updUser.Name != "" &amp;&amp; updUser.Avatar == "":<span class="cov0" title="0">
                err = r.DB.Get(user, `UPDATE users SET name=$1, email=$2 WHERE id=$3 RETURNING id, name, email, phone, avatar`, updUser.Name, updUser.Email, updUser.Id)</span>
        case updUser.Email != "" &amp;&amp; updUser.Name == "" &amp;&amp; updUser.Avatar != "":<span class="cov0" title="0">
                err = r.DB.Get(user, `UPDATE users SET email=$1, avatar=$2 WHERE id=$3 RETURNING id, name, email, phone, avatar`, updUser.Email, updUser.Avatar, updUser.Id)</span>
        case updUser.Email == "" &amp;&amp; updUser.Name != "" &amp;&amp; updUser.Avatar != "":<span class="cov0" title="0">
                err = r.DB.Get(user, `UPDATE users SET name=$1, avatar=$2 WHERE id=$3 RETURNING id, name, email, phone, avatar`, updUser.Name, updUser.Avatar, updUser.Id)</span>
        default:<span class="cov0" title="0">
                return nil, nil</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrConnDone || err == sql.ErrTxDone </span><span class="cov0" title="0">{
                        return nil, servErrors.NewError(servErrors.DB_ERROR, err.Error())
                }</span>
                <span class="cov0" title="0">if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, err.Error())
                }</span>
                <span class="cov0" title="0">return nil, servErrors.NewError(servErrors.DB_UPDATE, err.Error())</span>
        }
        //if count, _ := result.RowsAffected(); count != 1 {
        //        return nil, servErrors.NewError(servErrors.DB_UPDATE, "")
        //}
        <span class="cov0" title="0">return user, nil</span>
}

func (r *UserRepo) HasUserByPhone(phone string) (bool, error) <span class="cov0" title="0">{
        user := &amp;models.UserDataRepo{}
        err := r.DB.Get(user, `SELECT id FROM users WHERE phone = $1`, phone)
        fmt.Println(err)
        fmt.Println(user)
        switch err </span>{
        case nil:<span class="cov0" title="0">
                return true, nil</span>
        case sql.ErrNoRows:<span class="cov0" title="0">
                return false, nil</span>
        default:<span class="cov0" title="0">
                return false, servErrors.NewError(servErrors.DB_ERROR, err.Error())</span>
        }
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package ucase

import (
        "context"
        "fmt"
        "io"

        "github.com/disintegration/imaging"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/models"
        cacher "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/cacher"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/notification"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/servErrors"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/staticManager"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/user"
        authProto "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/auth/proto"
        "github.com/google/uuid"
        "github.com/pkg/errors"
        "google.golang.org/grpc/status"
)

// TODO: удалить
var LOGIN_CODE string

// const (
// avatarSide           = 300
// avatarSide = 30
// )

type UserUcase struct {
        Notificator   notification.Notificator
        Cacher        cacher.Cacher
        UserRepo      user.Repository
        StaticManager staticManager.FileManager
        Authorizer    authProto.AuthServiceClient
}

func NewUcase(notificator notification.Notificator, cacher cacher.Cacher, userRepo user.Repository, staticManager staticManager.FileManager, authorizer authProto.AuthServiceClient) *UserUcase <span class="cov0" title="0">{
        return &amp;UserUcase{
                Notificator:   notificator,
                Cacher:        cacher,
                UserRepo:      userRepo,
                StaticManager: staticManager,
                Authorizer:    authorizer,
        }
}</span>

func (u *UserUcase) SendCode(req *models.SendCodeUcaseReq) (models.SendCodeUcaseResp, error) <span class="cov0" title="0">{
        fmt.Println("send-code-u")
        isRegistered, err := u.Authorizer.SendCode(context.Background(), &amp;authProto.SendCodeReq{Phone: req.Phone})
        fmt.Println("send-code-eu")
        fmt.Println(isRegistered, err)
        if err != nil </span><span class="cov0" title="0">{
                return models.SendCodeUcaseResp{IsRegistered: false}, servErrors.NewError(int(status.Code(err)), err.Error())
        }</span>
        <span class="cov0" title="0">return models.SendCodeUcaseResp{IsRegistered: isRegistered.IsRegistered}, err</span>
}

func (u *UserUcase) Register(req *models.RegisterUcaseReq) (*models.UserDataUcase, error) <span class="cov0" title="0">{
        fmt.Println("reg-u")
        userData, err := u.Authorizer.Register(context.Background(), &amp;authProto.RegisterReq{Phone: req.Phone, Code: req.Code, Name: req.Name, Email: req.Email})
        fmt.Println("reg-eu")
        fmt.Println(userData, err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, servErrors.NewError(int(status.Code(err)), err.Error())
        }</span>
        <span class="cov0" title="0">return &amp;models.UserDataUcase{Id: models.UserId(userData.Id), Phone: userData.Phone, Name: userData.Name, Email: userData.Email, Avatar: userData.Avatar}, err</span>
}

func (u *UserUcase) Login(req *models.LoginUcaseReq) (*models.UserDataUcase, error) <span class="cov0" title="0">{
        fmt.Println("reg-u")
        userData, err := u.Authorizer.Login(context.Background(), &amp;authProto.LoginReq{Phone: req.Phone, Code: req.Code})
        fmt.Println("reg-eu")
        fmt.Println(userData, err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, servErrors.NewError(int(status.Code(err)), err.Error())
        }</span>
        <span class="cov0" title="0">return &amp;models.UserDataUcase{Id: models.UserId(userData.Id), Phone: userData.Phone, Name: userData.Name, Email: userData.Email, Avatar: userData.Avatar}, err</span>
}

func (u *UserUcase) GetUser(id models.UserId) (*models.UserDataUcase, error) <span class="cov0" title="0">{
        userData, err := u.UserRepo.GetUserById(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "error getting user by id %d", id)
        }</span>
        <span class="cov0" title="0">return &amp;models.UserDataUcase{
                Id:     userData.Id,
                Phone:  userData.Phone,
                Name:   userData.Name,
                Email:  userData.Email,
                Avatar: userData.Avatar.String,
        }, nil</span>
}

func (u *UserUcase) UpdateUser(updates *models.UpdateUserUcase) (*models.UserDataUcase, error) <span class="cov0" title="0">{
        var newAvatarName string
        var err error
        if updates.AvatarImg != nil </span><span class="cov0" title="0">{
                newAvatarName, err = u.saveNewAvatar(updates.AvatarImg)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "error saving new avatar to server")
                }</span>
        }
        <span class="cov0" title="0">updUser, err := u.UserRepo.UpdateUser(&amp;models.UpdateUserStorage{Id: updates.Id, Email: updates.Email, Name: updates.Name, Avatar: newAvatarName})
        if err != nil </span><span class="cov0" title="0">{
                if newAvatarName != "" </span><span class="cov0" title="0">{
                        u.StaticManager.RemoveAvatar(newAvatarName)
                        // os.Remove(avatarPath + newAvatarName)
                }</span>
                <span class="cov0" title="0">return nil, errors.Wrap(err, "error updating user")</span>
        }
        <span class="cov0" title="0">if updUser == nil </span><span class="cov0" title="0">{
                if newAvatarName != "" </span><span class="cov0" title="0">{
                        u.StaticManager.RemoveAvatar(newAvatarName)
                        // os.Remove(avatarPath + newAvatarName)
                }</span>
                <span class="cov0" title="0">updUser, err = u.UserRepo.GetUserById(updates.Id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrapf(err, "error getting user by id %d", updates.Id)
                }</span>
        }
        <span class="cov0" title="0">return &amp;models.UserDataUcase{
                Id:     updUser.Id,
                Phone:  updUser.Phone,
                Name:   updUser.Name,
                Email:  updUser.Email,
                Avatar: updUser.Avatar.String,
        }, nil</span>
}

// /*
func (u *UserUcase) saveNewAvatar(avatar io.Reader) (string, error) <span class="cov0" title="0">{
        avatarImg, err := imaging.Decode(avatar)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
                return "", servErrors.NewError(servErrors.DECODE_IMG, err.Error())
        }</span>

        // if avatarImg.Bounds().Max.X &lt; avatarImg.Bounds().Max.Y {
        //         avatarImg = imaging.Resize(avatarImg, avatarSide, 0, imaging.Lanczos)
        // } else {
        //         avatarImg = imaging.Resize(avatarImg, 0, avatarSide, imaging.Lanczos)
        // }

        <span class="cov0" title="0">var avatarName string
        for i := 0; i &lt; 10; i++ </span><span class="cov0" title="0">{
                avatarName = newAvatarName() + ".png"
                if u.StaticManager.IsNotSuchAvatarExist(avatarName) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">avatarName = ""</span>
        }
        <span class="cov0" title="0">if avatarName == "" </span><span class="cov0" title="0">{
                return "", servErrors.NewError(servErrors.CANT_CREATE_AVATAR_NAME, "")
        }</span>

        <span class="cov0" title="0">err = u.StaticManager.SafeAvatar(avatarImg, avatarName)
        fmt.Println(err)
        fmt.Println(avatarName)
        if err != nil </span><span class="cov0" title="0">{
                return "", servErrors.NewError(servErrors.CANT_SAVE_AVATAR, err.Error())
        }</span>

        <span class="cov0" title="0">return avatarName, nil</span>
}

func newAvatarName() string <span class="cov0" title="0">{
        fname, _ := uuid.NewUUID()
        return fname.String()
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package grpc

import (
        "context"
        "fmt"

        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/servErrors"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/auth"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/auth/models"
        proto "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/auth/proto"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

type grpcAuthHandler struct {
        Ucase auth.Ucase
        proto.UnimplementedAuthServiceServer
}

func NewAuthHandler(userUcase auth.Ucase) *grpcAuthHandler <span class="cov0" title="0">{
        return &amp;grpcAuthHandler{
                Ucase: userUcase,
        }
}</span>

func (h *grpcAuthHandler) SendCode(ctx context.Context, req *proto.SendCodeReq) (*proto.IsRegistered, error) <span class="cov0" title="0">{
        fmt.Println("grpc-h")
        isRegistered, err := h.Ucase.SendCode(&amp;models.SendCodeUcaseReq{Phone: req.GetPhone()})
        fmt.Println("grpc-eh")
        return &amp;proto.IsRegistered{IsRegistered: isRegistered.IsRegistered}, err
}</span>

func (h *grpcAuthHandler) Login(ctx context.Context, req *proto.LoginReq) (*proto.UserData, error) <span class="cov0" title="0">{
        fmt.Println("grpc-h")
        userDataUcase, err := h.Ucase.Login(&amp;models.LoginUcaseReq{Phone: req.GetPhone(), Code: req.Code})
        fmt.Println("grpc-eh")
        if err != nil </span><span class="cov0" title="0">{
                cause := servErrors.ErrorAs(err)
                if cause == nil </span><span class="cov0" title="0">{
                        return &amp;proto.UserData{}, status.Error(codes.Internal, err.Error())
                }</span>
                <span class="cov0" title="0">return &amp;proto.UserData{}, status.Error(codes.Code(cause.Code), err.Error())</span>
        }
        <span class="cov0" title="0">return &amp;proto.UserData{Id: uint64(userDataUcase.Id), Phone: userDataUcase.Phone, Email: userDataUcase.Email, Name: userDataUcase.Name, Avatar: userDataUcase.Avatar}, nil</span>
}

func (h *grpcAuthHandler) Register(ctx context.Context, req *proto.RegisterReq) (*proto.UserData, error) <span class="cov0" title="0">{
        fmt.Println("grpc-h")
        userDataUcase, err := h.Ucase.Register(&amp;models.RegisterUcaseReq{Phone: req.GetPhone(), Code: req.Code, Email: req.Email, Name: req.Name})
        fmt.Println("grpc-eh")
        if userDataUcase == nil </span><span class="cov0" title="0">{
                return &amp;proto.UserData{}, err
        }</span>
        <span class="cov0" title="0">return &amp;proto.UserData{Id: uint64(userDataUcase.Id), Phone: userDataUcase.Phone, Email: userDataUcase.Email, Name: userDataUcase.Name, Avatar: userDataUcase.Avatar}, err</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package repository

import (
        "database/sql"
        "fmt"

        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/servErrors"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/auth/models"
        "github.com/jmoiron/sqlx"
)

type AuthRepo struct {
        DB *sqlx.DB
}

func NewAuthRepo(db *sqlx.DB) *AuthRepo <span class="cov0" title="0">{
        return &amp;AuthRepo{DB: db}
}</span>

func (r *AuthRepo) GetUserByPhone(phone models.UserByPhoneRepoReq) (*models.UserDataRepo, error) <span class="cov0" title="0">{
        user := &amp;models.UserDataRepo{}
        err := r.DB.Get(user, `SELECT id, phone, email, name, avatar FROM users WHERE phone = $1`, phone.Phone)
        fmt.Println(err)
        fmt.Println(user)
        switch err </span>{
        case nil:<span class="cov0" title="0">
                return user, nil</span>
        case sql.ErrNoRows:<span class="cov0" title="0">
                return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, err.Error())</span>
        default:<span class="cov0" title="0">
                return nil, servErrors.NewError(servErrors.DB_ERROR, err.Error())</span>
        }
}

func (r *AuthRepo) AddUser(newUser *models.AddUserRepoReq) (*models.UserDataRepo, error) <span class="cov0" title="0">{
        user := &amp;models.UserDataRepo{}
        err := r.DB.Get(user, `INSERT INTO users (name,phone,email) VALUES ($1,$2,$3) RETURNING id, name, phone, email`, newUser.Name, newUser.Phone, newUser.Email)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrConnDone || err == sql.ErrTxDone </span><span class="cov0" title="0">{
                        return nil, servErrors.NewError(servErrors.DB_ERROR, err.Error())
                }</span>
                <span class="cov0" title="0">return nil, servErrors.NewError(servErrors.DB_INSERT, err.Error())</span>
        }
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                return nil, servErrors.NewError(servErrors.DB_INSERT, "")
        }</span>
        <span class="cov0" title="0">return user, nil</span>
}

func (r *AuthRepo) HasUserByPhone(phone models.UserByPhoneRepoReq) (models.HasSuchUserRepoResp, error) <span class="cov0" title="0">{
        user := &amp;models.UserDataRepo{}
        err := r.DB.Get(user, `SELECT id FROM users WHERE phone = $1`, phone.Phone)
        fmt.Println(err)
        fmt.Println(user)
        switch err </span>{
        case nil:<span class="cov0" title="0">
                return models.HasSuchUserRepoResp{IsRegistered: true}, nil</span>
        case sql.ErrNoRows:<span class="cov0" title="0">
                return models.HasSuchUserRepoResp{IsRegistered: false}, nil</span>
        default:<span class="cov0" title="0">
                return models.HasSuchUserRepoResp{IsRegistered: false}, servErrors.NewError(servErrors.DB_ERROR, err.Error())</span>
        }
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package ucase

import (
        "crypto/rand"
        "fmt"
        "math/big"
        "strconv"

        cacher "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/cacher"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/notification"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/servErrors"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/auth"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/auth/models"
        "github.com/pkg/errors"
)

// TODO: удалить
var LOGIN_CODE string

const (
        codeUpBound          = 10000 // &gt; 0
        codeExpiration int32 = 300   // 5 min
)

type AuthUcase struct {
        Notificator notification.Notificator
        Cacher      cacher.Cacher
        AuthRepo    auth.Repository
}

func NewAuthUcase(notificator notification.Notificator, cacher cacher.Cacher, authRepo auth.Repository) *AuthUcase <span class="cov0" title="0">{
        return &amp;AuthUcase{
                Notificator: notificator,
                Cacher:      cacher,
                AuthRepo:    authRepo,
        }
}</span>

func generateLoginCode() string <span class="cov0" title="0">{
        randNum, _ := rand.Int(rand.Reader, big.NewInt(codeUpBound))
        return strconv.Itoa(int(randNum.Int64()) + codeUpBound)[1:]
}</span>

func (u *AuthUcase) SendCode(req *models.SendCodeUcaseReq) (models.SendCodeUcaseResp, error) <span class="cov0" title="0">{
        loginCode := generateLoginCode()
        LOGIN_CODE = loginCode //TODO: удалить
        fmt.Printf("grpc~~~~~~~code: %s ~~~~~~~~\n", loginCode)
        err := u.Cacher.Set(cacher.NewItem(req.Phone, []byte(loginCode), codeExpiration))
        if err != nil </span><span class="cov0" title="0">{
                return models.SendCodeUcaseResp{IsRegistered: false}, errors.Wrap(err, "error saving [auth code destination]-code item to cach")
        }</span>

        <span class="cov0" title="0">err = u.Notificator.SendCode(req.Phone, loginCode)
        if err != nil </span><span class="cov0" title="0">{
                return models.SendCodeUcaseResp{IsRegistered: false}, errors.Wrap(err, "error sending message e with code to auth code destination")
        }</span>

        <span class="cov0" title="0">hasSuchUser, err := u.AuthRepo.HasUserByPhone(models.UserByPhoneRepoReq{Phone: req.Phone})
        if err != nil </span><span class="cov0" title="0">{
                return models.SendCodeUcaseResp{IsRegistered: false}, errors.Wrap(err, "error finding out if there is such user in database")
        }</span>
        <span class="cov0" title="0">return models.SendCodeUcaseResp(hasSuchUser), nil</span>
}

func (u *AuthUcase) isCodeCorrect(codeDst string, code string) (bool, error) <span class="cov0" title="0">{
        cachItem, err := u.Cacher.Get(codeDst)

        if err != nil || string(cachItem.Value) != code </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "code validation error")
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

func (u *AuthUcase) Login(req *models.LoginUcaseReq) (*models.UserDataUcase, error) <span class="cov0" title="0">{
        isCorrect, err := u.isCodeCorrect(req.Phone, req.Code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "code check failed")
        }</span>
        <span class="cov0" title="0">if !isCorrect </span><span class="cov0" title="0">{
                return nil, servErrors.NewError(servErrors.WRONG_AUTH_CODE, servErrors.WRONG_AUTH_CODE_DESCR)
        }</span>
        <span class="cov0" title="0">userData, err := u.AuthRepo.GetUserByPhone(models.UserByPhoneRepoReq{Phone: req.Phone})
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "error getting user by phone")
        }</span>
        <span class="cov0" title="0">return &amp;models.UserDataUcase{
                Id:     userData.Id,
                Phone:  userData.Phone,
                Name:   userData.Name,
                Email:  userData.Email,
                Avatar: userData.Avatar.String,
        }, nil</span>
}

func (u *AuthUcase) Register(req *models.RegisterUcaseReq) (*models.UserDataUcase, error) <span class="cov0" title="0">{
        isCorrect, err := u.isCodeCorrect(req.Phone, req.Code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "code check failed")
        }</span>
        <span class="cov0" title="0">if !isCorrect </span><span class="cov0" title="0">{
                return nil, servErrors.NewError(servErrors.WRONG_AUTH_CODE, servErrors.WRONG_AUTH_CODE_DESCR)
        }</span>

        <span class="cov0" title="0">userDataStorage, err := u.AuthRepo.AddUser(&amp;models.AddUserRepoReq{Phone: req.Phone, Email: req.Email, Name: req.Name})
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "error adding user to storage")
        }</span>
        <span class="cov0" title="0">return &amp;models.UserDataUcase{
                Id:    userDataStorage.Id,
                Phone: userDataStorage.Phone,
                Name:  userDataStorage.Name,
                Email: userDataStorage.Email,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package grpc

import (
        "context"

        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/servErrors"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/order"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/order/models"
        proto "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/order/proto"
)

type grpcOrderHandler struct {
        Ucase order.Ucase
        proto.UnimplementedOrderServiceServer
}

func NewOrderHandler(ucase order.Ucase) *grpcOrderHandler <span class="cov0" title="0">{
        return &amp;grpcOrderHandler{
                Ucase: ucase,
        }
}</span>

func (h grpcOrderHandler) CreateOrder(ctx context.Context, req *proto.CreateOrderReq) (*proto.CreateOrderResp, error) <span class="cov0" title="0">{
        cart := make([]models.OrderPositionUcase, len(req.Cart))
        for i, position := range req.Cart </span><span class="cov0" title="0">{
                cart[i] = models.OrderPositionUcase{Id: position.Id, Count: position.Count}
        }</span>
        <span class="cov0" title="0">orderResp, err := h.Ucase.CreateOrder(&amp;models.CreateOrderUcaseReq{Address: req.Address, Comment: req.Comment, UserId: req.UserId, Cart: cart})
        if err != nil </span><span class="cov0" title="0">{
                cause := servErrors.ErrorAs(err)
                if cause == nil </span><span class="cov0" title="0">{
                        return &amp;proto.CreateOrderResp{}, status.Error(codes.Internal, err.Error())
                }</span>
                <span class="cov0" title="0">return &amp;proto.CreateOrderResp{}, status.Error(codes.Code(cause.Code), err.Error())</span>
        }
        <span class="cov0" title="0">return &amp;proto.CreateOrderResp{OrderId: orderResp.OrderId}, nil</span>
}

func (h grpcOrderHandler) GetUserOrders(ctx context.Context, req *proto.GetUserOrdersReq) (*proto.GetUserOrdersResp, error) <span class="cov0" title="0">{
        ordersUcaseResp, err := h.Ucase.GetUserOrders(&amp;models.GetUserOrdersUcaseReq{UserId: req.UserId})
        if err != nil </span><span class="cov0" title="0">{
                cause := servErrors.ErrorAs(err)
                if cause == nil </span><span class="cov0" title="0">{
                        return &amp;proto.GetUserOrdersResp{}, status.Error(codes.Internal, err.Error())
                }</span>
                <span class="cov0" title="0">return &amp;proto.GetUserOrdersResp{}, status.Error(codes.Code(cause.Code), err.Error())</span>
        }
        <span class="cov0" title="0">ordersResp := make([]*proto.ShortOrderResp, len(ordersUcaseResp.Orders))
        for i, position := range ordersUcaseResp.Orders </span><span class="cov0" title="0">{
                ordersResp[i] = &amp;proto.ShortOrderResp{OrderId: position.OrderId, Date: position.Date, RestaurantName: position.RestaurantName, Status: position.Status, TotalPrice: position.TotalPrice}
        }</span>
        <span class="cov0" title="0">return &amp;proto.GetUserOrdersResp{Orders: ordersResp}, nil</span>
}

func (h grpcOrderHandler) GetUserOrderStatuses(ctx context.Context, req *proto.GetUserOrderStatusesReq) (*proto.GetUserOrderStatusesResp, error) <span class="cov0" title="0">{
        ordersUcaseResp, err := h.Ucase.GetUserOrders(&amp;models.GetUserOrdersUcaseReq{UserId: req.UserId})
        if err != nil </span><span class="cov0" title="0">{
                cause := servErrors.ErrorAs(err)
                if cause == nil </span><span class="cov0" title="0">{
                        return &amp;proto.GetUserOrderStatusesResp{}, status.Error(codes.Internal, err.Error())
                }</span>
                <span class="cov0" title="0">return &amp;proto.GetUserOrderStatusesResp{}, status.Error(codes.Code(cause.Code), err.Error())</span>
        }
        <span class="cov0" title="0">ordersStatusesResp := make([]*proto.OrderStatus, len(ordersUcaseResp.Orders))
        for i, position := range ordersUcaseResp.Orders </span><span class="cov0" title="0">{
                ordersStatusesResp[i] = &amp;proto.OrderStatus{OrderId: position.OrderId, Status: position.Status}
        }</span>
        <span class="cov0" title="0">return &amp;proto.GetUserOrderStatusesResp{OrderStatuses: ordersStatusesResp}, nil</span>
}

func (h grpcOrderHandler) GetUserOrder(ctx context.Context, req *proto.GetUserOrderReq) (*proto.GetUserOrderResp, error) <span class="cov0" title="0">{
        order, err := h.Ucase.GetUserOrder(&amp;models.GetUserOrderUcaseReq{UserId: req.UserId, OrderId: req.OrderId})
        if err != nil </span><span class="cov0" title="0">{
                cause := servErrors.ErrorAs(err)
                if cause == nil </span><span class="cov0" title="0">{
                        return &amp;proto.GetUserOrderResp{}, status.Error(codes.Internal, err.Error())
                }</span>
                <span class="cov0" title="0">return &amp;proto.GetUserOrderResp{}, status.Error(codes.Code(cause.Code), err.Error())</span>
        }

        <span class="cov0" title="0">cart := make([]*proto.OrderPositionResp, len(order.Cart))
        for i, poz := range order.Cart </span><span class="cov0" title="0">{
                cart[i] = &amp;proto.OrderPositionResp{Name: poz.Name, Description: poz.Description, ImagePath: poz.ImagePath, Calories: poz.Calories, Count: poz.Count, Price: poz.Price, Weigth: poz.Weigth}
        }</span>

        <span class="cov0" title="0">return &amp;proto.GetUserOrderResp{OrderId: order.OrderId, Address: order.Address, Date: order.Date, RestaurantName: order.RestaurantName, RestaurantSlug: order.RestaurantSlug, TotalPrice: order.TotalPrice, Status: order.Status, Cart: cart}, nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package repository

import (
        "database/sql"
        "strconv"

        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/servErrors"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/order/models"
        "github.com/jmoiron/sqlx"
)

type OrderRepo struct {
        DB *sqlx.DB
}

const (
        ordersMax = 100
)

func NewOrderRepo(db *sqlx.DB) *OrderRepo <span class="cov0" title="0">{
        return &amp;OrderRepo{DB: db}
}</span>

func makeAddOrderQuery(order *models.CreateOrderRepoReq) string <span class="cov0" title="0">{
        // INSERT INTO orders (user_id , address, comment, cart) VALUES ($1,$2,$3, ARRAY[($4,$5)::order_position, ($6,$7)::order_position])`
        query := `INSERT INTO orders_internal (user_id , address, comment, cart) VALUES ($1,$2,$3, ARRAY[`

        nextPlaceholderNum := 4
        for i := 0; i &lt; len(order.Cart)-1; i++ </span><span class="cov0" title="0">{
                query += `($` + strconv.Itoa(nextPlaceholderNum)
                nextPlaceholderNum++
                query += `,$` + strconv.Itoa(nextPlaceholderNum)
                nextPlaceholderNum++
                query += `,$` + strconv.Itoa(nextPlaceholderNum) + `)::order_dish,`
                nextPlaceholderNum++
        }</span>
        <span class="cov0" title="0">query += `($` + strconv.Itoa(nextPlaceholderNum)
        nextPlaceholderNum++
        query += `,$` + strconv.Itoa(nextPlaceholderNum)
        nextPlaceholderNum++
        query += `,$` + strconv.Itoa(nextPlaceholderNum) + `)::order_dish]) RETURNING id`
        return query</span>
}

func expandOrder(order *models.CreateOrderRepoReq) []interface{} <span class="cov0" title="0">{
        var args []interface{}
        args = append(args, order.UserId, order.Address, order.Comment)
        for _, orderPos := range order.Cart </span><span class="cov0" title="0">{
                args = append(args, orderPos.Id, orderPos.Count, 0)
        }</span>
        <span class="cov0" title="0">return args</span>
}

func (r *OrderRepo) CreateOrder(order *models.CreateOrderRepoReq) (*models.CreateOrderRepoResp, error) <span class="cov0" title="0">{
        query := makeAddOrderQuery(order)

        var newOrderId int64
        err := r.DB.QueryRow(query, expandOrder(order)...).Scan(&amp;newOrderId)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrConnDone || err == sql.ErrTxDone </span><span class="cov0" title="0">{
                        return nil, servErrors.NewError(servErrors.DB_ERROR, err.Error())
                }</span>
                <span class="cov0" title="0">return nil, servErrors.NewError(servErrors.DB_INSERT, err.Error())</span>
        }
        <span class="cov0" title="0">if newOrderId == 0 </span><span class="cov0" title="0">{
                return nil, servErrors.NewError(servErrors.DB_INSERT, "")
        }</span>
        <span class="cov0" title="0">return &amp;models.CreateOrderRepoResp{OrderId: newOrderId}, nil</span>
}

func (r *OrderRepo) GetUserOrders(user *models.GetUserOrdersRepoReq) (*models.GetUserOrdersRepoResp, error) <span class="cov0" title="0">{
        orders := make([]*models.ShortOrderRepo, 0, ordersMax)
        err := r.DB.Select(&amp;orders, `SELECT id, date, restaurant_name, total_price, status FROM orders WHERE user_id = $1 ORDER BY fulldate DESC `, user.UserId)

        ordersResp := make([]models.ShortOrderRepo, len(orders))
        for i, order := range orders </span><span class="cov0" title="0">{
                ordersResp[i] = *order
        }</span>
        <span class="cov0" title="0">switch err </span>{
        case nil:<span class="cov0" title="0">
                return &amp;models.GetUserOrdersRepoResp{OrderStatuses: ordersResp}, nil</span>
        case sql.ErrNoRows:<span class="cov0" title="0">
                return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, err.Error())</span>
        default:<span class="cov0" title="0">
                return nil, servErrors.NewError(servErrors.DB_ERROR, err.Error())</span>
        }
}

func (r *OrderRepo) GetUserOrderStatuses(user *models.GetUserOrderStatusesRepoReq) (*models.GetUserOrderStatusesRepoResp, error) <span class="cov0" title="0">{
        orderStatuses := make([]*models.OrderStatusRepo, 0, ordersMax)
        err := r.DB.Select(&amp;orderStatuses, `SELECT id, status FROM orders WHERE user_id = $1 ORDER BY fulldate DESC`, user.UserId)

        ordersResp := make([]models.OrderStatusRepo, len(orderStatuses))
        for i, order := range orderStatuses </span><span class="cov0" title="0">{
                ordersResp[i] = *order
        }</span>
        <span class="cov0" title="0">switch err </span>{
        case nil:<span class="cov0" title="0">
                return &amp;models.GetUserOrderStatusesRepoResp{OrderStatuses: ordersResp}, nil</span>
        case sql.ErrNoRows:<span class="cov0" title="0">
                return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, err.Error())</span>
        default:<span class="cov0" title="0">
                return nil, servErrors.NewError(servErrors.DB_ERROR, err.Error())</span>
        }
}

func (r *OrderRepo) GetUserOrder(req *models.GetUserOrderRepoReq) (*models.GetUserOrderRepoResp, error) <span class="cov0" title="0">{
        order := &amp;models.GetUserOrderRepoResp{}
        err := r.DB.Get(order, `SELECT id, address, user_id, date, restaurant_name, restaurant_slug, total_price, status FROM orders WHERE id = $1 `, req.OrderId)
        cart := make([]*models.OrderPositionRepoResp, 0)
        if err == nil </span><span class="cov0" title="0">{
                err = r.DB.Select(&amp;cart, `SELECT d.description, d.name, d.weight, d.calories, d.image_path, c.price price, c.count from dishes d JOIN (SELECT (unnest(cart)::order_dish).id as id, (unnest(cart)::order_dish).count, (unnest(cart)::order_dish).price FROM orders_internal WHERE id=$1) c ON d.id=c.id`, req.OrderId)
                if err == nil </span><span class="cov0" title="0">{
                        order.Cart = make([]models.OrderPositionRepoResp, len(cart))
                        for i, poz := range cart </span><span class="cov0" title="0">{
                                order.Cart[i] = *poz
                        }</span>
                }
        }
        <span class="cov0" title="0">switch err </span>{
        case nil:<span class="cov0" title="0">
                return order, nil</span>
        case sql.ErrNoRows:<span class="cov0" title="0">
                return nil, servErrors.NewError(servErrors.NO_SUCH_ENTITY_IN_DB, err.Error())</span>
        default:<span class="cov0" title="0">
                return nil, servErrors.NewError(servErrors.DB_ERROR, err.Error())</span>
        }
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package ucase

import (
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/app/tools/servErrors"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/order"
        "github.com/go-park-mail-ru/2022_1_VVT-i-2.0/internal/microservices/order/models"
        "github.com/pkg/errors"
)

type OrderUcase struct {
        OrderRepo order.Repository
}

func NewOrderUcase(orderRepo order.Repository) *OrderUcase <span class="cov0" title="0">{
        return &amp;OrderUcase{
                OrderRepo: orderRepo,
        }
}</span>

func (u *OrderUcase) CreateOrder(order *models.CreateOrderUcaseReq) (*models.CreateOrderUcaseResp, error) <span class="cov0" title="0">{
        // TODO: сделать проверку, есть ли такой адрес
        cart := make([]models.OrderPositionRepo, len(order.Cart))
        for i, position := range order.Cart </span><span class="cov0" title="0">{
                cart[i] = models.OrderPositionRepo(position)
        }</span>
        <span class="cov0" title="0">orderId, err := u.OrderRepo.CreateOrder(&amp;models.CreateOrderRepoReq{UserId: order.UserId, Address: order.Address, Comment: order.Comment, Cart: cart})

        if err != nil || orderId.OrderId &lt;= 0 </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "error adding order to storage")
        }</span>
        <span class="cov0" title="0">return &amp;models.CreateOrderUcaseResp{OrderId: orderId.OrderId}, nil</span>

}

func (u *OrderUcase) GetUserOrders(user *models.GetUserOrdersUcaseReq) (*models.GetUserOrdersUcaseResp, error) <span class="cov0" title="0">{

        orders, err := u.OrderRepo.GetUserOrders(&amp;models.GetUserOrdersRepoReq{UserId: user.UserId})

        if err != nil || orders == nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "error getting orders from storage")
        }</span>
        <span class="cov0" title="0">ordersResp := make([]models.ShortOrderUcase, len(orders.OrderStatuses))
        for i, position := range orders.OrderStatuses </span><span class="cov0" title="0">{
                ordersResp[i] = models.ShortOrderUcase(position)
        }</span>
        <span class="cov0" title="0">return &amp;models.GetUserOrdersUcaseResp{Orders: ordersResp}, nil</span>
}

func (u *OrderUcase) GetUserOrderStatuses(user *models.GetUserOrderStatusesUcaseReq) (*models.GetUserOrderStatusesUcaseResp, error) <span class="cov0" title="0">{

        orderStatuses, err := u.OrderRepo.GetUserOrderStatuses(&amp;models.GetUserOrderStatusesRepoReq{UserId: user.UserId})

        if err != nil || orderStatuses == nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "error getting orders from storage")
        }</span>
        <span class="cov0" title="0">orderStatusesResp := make([]models.OrderStatusUcase, len(orderStatuses.OrderStatuses))
        for i, position := range orderStatuses.OrderStatuses </span><span class="cov0" title="0">{
                orderStatusesResp[i] = models.OrderStatusUcase(position)
        }</span>
        <span class="cov0" title="0">return &amp;models.GetUserOrderStatusesUcaseResp{OrderStatuses: orderStatusesResp}, nil</span>
}

func (u *OrderUcase) GetUserOrder(req *models.GetUserOrderUcaseReq) (*models.GetUserOrderUcaseResp, error) <span class="cov0" title="0">{

        order, err := u.OrderRepo.GetUserOrder(&amp;models.GetUserOrderRepoReq{OrderId: req.OrderId})

        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "error getting orders from storage")
        }</span>

        <span class="cov0" title="0">if order.UserId != req.UserId </span><span class="cov0" title="0">{
                return nil, servErrors.NewError(servErrors.THIS_ORDER_DOESNOT_BELONG_USER, "")
        }</span>
        <span class="cov0" title="0">cart := make([]models.OrderPositionUcaseResp, len(order.Cart))
        for i, poz := range order.Cart </span><span class="cov0" title="0">{
                cart[i] = models.OrderPositionUcaseResp{Name: poz.Name, Description: poz.Description, ImagePath: poz.ImagePath, Calories: poz.Calories, Count: poz.Count, Price: poz.Price, Weigth: poz.Weight}
        }</span>

        <span class="cov0" title="0">return &amp;models.GetUserOrderUcaseResp{OrderId: order.OrderId, Address: order.Address, Date: order.Date, RestaurantName: order.RestaurantName, RestaurantSlug: order.RestaurantSlug, TotalPrice: order.TotalPrice, Status: order.Status, Cart: cart}, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
